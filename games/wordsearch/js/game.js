const GRID_SIZE = 10;const WORDS_TO_SELECT = 10;const MASTER_WORD_LIST = [        "العلوم", "الرياضيات", "الحاسوب", "التاريخ", "الجغرافيا", "الرسم", "المدرسة", "المعلم", "الكتاب", "القلم",    "النجاح", "الإبداع", "الفصل", "السبورة", "الدفتر", "القراءة", "الكتابة", "الامتحان", "الدروس", "المكتبة",    "المدير", "التلميذ", "الواجب", "البحث", "المعرفة", "الثقافة", "التعليم", "الجامعة", "الدراسة", "الممحاة",        "الصدق", "الأمانة", "الاحترام", "التعاون", "الصداقة", "المحبة", "التسامح", "العدل", "الكرم", "الشجاعة",    "الصبر", "الإخلاص", "الوفاء", "التواضع", "الحكمة", "الأمل", "التفاؤل", "الاجتهاد", "النظام", "النظافة",        "الشمس", "القمر", "النجوم", "السماء", "الأرض", "البحر", "النهر", "الجبل", "الشجرة", "الزهرة",    "الغابة", "المطر", "السحاب", "الرياح", "الثلج", "الربيع", "الصيف", "الخريف", "الشتاء", "الصحراء",    "الماء", "الهواء", "الطبيعة", "البيئة", "الحديقة", "البستان", "النخيل", "الواحة", "الرمل", "الصخر",        "الأسد", "النمر", "الفيل", "الزرافة", "الغزال", "الحصان", "الجمل", "القطة", "الكلب", "العصفور",    "النسر", "الصقر", "البطريق", "الدلفين", "الحوت", "السمكة", "الفراشة", "النحلة", "النملة", "الأرنب",    "الثعلب", "الذئب", "الدب", "القرد", "الببغاء", "الحمامة", "النعامة", "التمساح", "السلحفاة", "الضفدع",        "الذرة", "الطاقة", "الكهرباء", "المغناطيس", "الجاذبية", "الفضاء", "المجرة", "الكوكب", "المركبة", "الروبوت",    "الشاشة", "المعالج", "الإنترنت", "الموقع", "الملف", "البيانات", "البرمجة", "الشبكة", "الهاتف", "الحاسب",    "المحرك", "العدسة", "المجهر", "المختبر", "التجربة", "الفرضية", "النتيجة", "البرهان", "المعادلة", "الرقم",        "المغرب", "فلسطين", "مصر", "القدس", "مكة", "المدينة", "الوطن", "العلم", "الخريطة", "البوصلة",    "القارة", "المحيط", "الجزيرة", "الوادي", "السهل", "الهضبة", "القرية", "المدينة", "المسجد", "المنزل",    "الشارع", "الحي", "السوق", "المطار", "الميناء", "الملعب", "المسرح", "المتحف", "القلعة", "البرج",        "التفاح", "الموز", "البرتقال", "العنب", "التمر", "الزيتون", "الخبز", "الحليب", "العسل", "الماء",    "الطعام", "الغذاء", "الصحة", "الجسم", "الرياضة", "القوة", "النمو", "الفيتامين", "الخضر", "الفواكه",        "الأحمر", "الأزرق", "الأخضر", "الأصفر", "الأبيض", "الأسود", "الدائرة", "المربع", "المثلث", "النقطة",    "الخط", "اللون", "الرسام", "اللوحة", "الفن", "الجمال", "الضوء", "الظلام", "الظل", "الشكل",        "الأب", "الأم", "الأخ", "الأخت", "الجد", "الجدة", "الأسرة", "العائلة", "الجار", "الصديق",    "الطفل", "الرجل", "المرأة", "الإنسان", "الناس", "المجتمع", "الشعب", "الأمة", "الضيف", "القريب",        "الوقت", "الساعة", "اليوم", "الأمس", "الغد", "السنة", "الشهر", "العيد", "الفرح", "السعادة"];const ARABIC_LETTERS = "أبتثجحخدذرزسشصضطظعغفقكلمنهوي";let grid = []; let wordsToFind = [];let selectionStart = null;let currentEnd = null;let isSelecting = false;let foundCount = 0;let hintCount = 3;let timerInterval = null;let secondsElapsed = 0;let soundEnabled = true;const gridWrapper = document.querySelector('.game-grid-wrapper');const gridEl = document.getElementById('game-grid');const canvas = document.getElementById('selectionCanvas');const ctx = canvas.getContext('2d');const wordListEl = document.getElementById('word-list');const timeEl = document.getElementById('time');const foundCountEl = document.getElementById('found-count');const totalCountEl = document.getElementById('total-count');const hintsLeftEl = document.getElementById('hints-left');const modalEl = document.getElementById('win-modal');const audioCtx = new (window.AudioContext || window.webkitAudioContext)();function playTone(freq, type = 'sine', duration = 0.1) {    if (!soundEnabled) return;    try {        const osc = audioCtx.createOscillator();        const gain = audioCtx.createGain();        osc.type = type;        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);        osc.connect(gain);        gain.connect(audioCtx.destination);        osc.start();        osc.stop(audioCtx.currentTime + duration);    } catch (e) { }}function playSound(action) {    if (audioCtx.state === 'suspended') audioCtx.resume();    switch (action) {        case 'select': playTone(400, 'sine', 0.05); break;        case 'found':            playTone(600, 'sine', 0.1);            setTimeout(() => playTone(800, 'sine', 0.2), 100);            break;        case 'win': [400, 500, 600, 800].forEach((f, i) => setTimeout(() => playTone(f, 'square', 0.2), i * 150)); break;        case 'error': playTone(150, 'sawtooth', 0.2); break;    }}function resizeCanvas() {    const rect = gridWrapper.getBoundingClientRect();    canvas.width = rect.width;    canvas.height = rect.height;    }window.addEventListener('resize', resizeCanvas);function getCellCenter(r, c) {    const cell = document.querySelector(`.cell[data-r='${r}'][data-c='${c}']`);    if (!cell) return null;            const cellRect = cell.getBoundingClientRect();    const wrapperRect = gridWrapper.getBoundingClientRect();    return {        x: (cellRect.left - wrapperRect.left) + cellRect.width / 2,        y: (cellRect.top - wrapperRect.top) + cellRect.height / 2    };}function drawLine(startR, startC, endR, endC, color = 'rgba(59, 130, 246, 0.5)') {    const start = getCellCenter(startR, startC);    const end = getCellCenter(endR, endC);    if (!start || !end) return;    ctx.strokeStyle = color;    ctx.lineCap = 'round';    ctx.lineWidth = 30;     ctx.beginPath();    ctx.moveTo(start.x, start.y);    ctx.lineTo(end.x, end.y);    ctx.stroke();}function clearCanvas() {    ctx.clearRect(0, 0, canvas.width, canvas.height);}function initGame() {    clearInterval(timerInterval);    secondsElapsed = 0;    updateTimer();    foundCount = 0;    hintCount = 3;    updateStats();    modalEl.classList.add('hidden');    wordListEl.innerHTML = '';    gridEl.innerHTML = '';    gridEl.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;    grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));    wordsToFind = [];        const shuffledMaster = [...MASTER_WORD_LIST].sort(() => 0.5 - Math.random());    const selectedWords = shuffledMaster.slice(0, WORDS_TO_SELECT);            for (const word of selectedWords) {        if (placeWord(word)) wordsToFind.push({ word, found: false });    }    for (let r = 0; r < GRID_SIZE; r++) {        for (let c = 0; c < GRID_SIZE; c++) {            if (!grid[r][c]) grid[r][c] = ARABIC_LETTERS[Math.floor(Math.random() * ARABIC_LETTERS.length)];            createCell(r, c, grid[r][c]);        }    }    renderWordList();        requestAnimationFrame(() => {        resizeCanvas();        startTimer();    });}function placeWord(word) {    const directions = [[0, 1], [0, -1], [1, 0], [1, 1], [1, -1]];    for (let attempt = 0; attempt < 50; attempt++) {        const dir = directions[Math.floor(Math.random() * directions.length)];        const startRow = Math.floor(Math.random() * GRID_SIZE);        const startCol = Math.floor(Math.random() * GRID_SIZE);        if (canPlace(word, startRow, startCol, dir)) {            for (let i = 0; i < word.length; i++) grid[startRow + i * dir[0]][startCol + i * dir[1]] = word[i];            return true;        }    }    return false;}function canPlace(word, r, c, dir) {    const endR = r + (word.length - 1) * dir[0];    const endC = c + (word.length - 1) * dir[1];    if (endR < 0 || endR >= GRID_SIZE || endC < 0 || endC >= GRID_SIZE) return false;    for (let i = 0; i < word.length; i++) {        const val = grid[r + i * dir[0]][c + i * dir[1]];        if (val !== null && val !== word[i]) return false;    }    return true;}function createCell(r, c, char) {    const cell = document.createElement('div');    cell.className = 'cell';    cell.dataset.r = r;    cell.dataset.c = c;    cell.textContent = char;    gridEl.appendChild(cell);}gridWrapper.addEventListener('mousedown', handleStart);gridWrapper.addEventListener('touchstart', handleStart, { passive: false });window.addEventListener('mousemove', handleMove);window.addEventListener('touchmove', handleMove, { passive: false });window.addEventListener('mouseup', handleEnd);window.addEventListener('touchend', handleEnd);function handleStart(e) {    e.preventDefault();    const target = e.target;    if (!target.classList.contains('cell')) return;    isSelecting = true;    selectionStart = { r: parseInt(target.dataset.r), c: parseInt(target.dataset.c) };    currentEnd = selectionStart;    playSound('select');    renderLoop();}function handleMove(e) {    if (!isSelecting) return;        let clientX, clientY;    if (e.touches) {        clientX = e.touches[0].clientX;        clientY = e.touches[0].clientY;    } else {        clientX = e.clientX;        clientY = e.clientY;    }            const target = document.elementFromPoint(clientX, clientY);    if (target && target.classList.contains('cell')) {        const r = parseInt(target.dataset.r);        const c = parseInt(target.dataset.c);                const dR = r - selectionStart.r;        const dC = c - selectionStart.c;                if (dR === 0 || dC === 0 || Math.abs(dR) === Math.abs(dC)) {            currentEnd = { r, c };        }    }}function handleEnd(e) {    if (!isSelecting) return;    isSelecting = false;        verifySelection();    clearCanvas(); }function renderLoop() {    if (!isSelecting) return;    clearCanvas();         if (selectionStart && currentEnd) {        drawLine(selectionStart.r, selectionStart.c, currentEnd.r, currentEnd.c, 'rgba(245, 158, 11, 0.6)');     }    requestAnimationFrame(renderLoop);}function verifySelection() {    if (!selectionStart || !currentEnd) return;        const dR = currentEnd.r - selectionStart.r;    const dC = currentEnd.c - selectionStart.c;    const steps = Math.max(Math.abs(dR), Math.abs(dC));    if (steps === 0) return;     const rDir = dR === 0 ? 0 : dR / Math.abs(dR);    const cDir = dC === 0 ? 0 : dC / Math.abs(dC);    let selectedWord = "";    let cells = [];    for (let i = 0; i <= steps; i++) {        const r = selectionStart.r + i * rDir;        const c = selectionStart.c + i * cDir;        selectedWord += grid[r][c];        cells.push({ r, c });    }    checkWord(selectedWord, cells);}function checkWord(word, cells) {    let foundObj = wordsToFind.find(w => w.word === word && !w.found);    if (!foundObj) {        const reversed = word.split('').reverse().join('');        foundObj = wordsToFind.find(w => w.word === reversed && !w.found);    }    if (foundObj) {        foundObj.found = true;        foundCount++;        playSound('found');                cells.forEach(pos => {            const cell = document.querySelector(`.cell[data-r='${pos.r}'][data-c='${pos.c}']`);            if (cell) cell.classList.add('found');        });        updateStats();        renderWordList();        if (foundCount === wordsToFind.length) gameWin();    } else {        playSound('error');    }}function renderWordList() {    wordListEl.innerHTML = wordsToFind.map(w => `<li class="word-item ${w.found ? 'found' : ''}">${w.word}</li>`).join('');    totalCountEl.textContent = wordsToFind.length;}function updateStats() {    foundCountEl.textContent = foundCount;    hintsLeftEl.textContent = hintCount;}function startTimer() {    timerInterval = setInterval(() => {        secondsElapsed++;        updateTimer();    }, 1000);}function updateTimer() {    const mins = Math.floor(secondsElapsed / 60).toString().padStart(2, '0');    const secs = (secondsElapsed % 60).toString().padStart(2, '0');    timeEl.textContent = `${mins}:${secs}`;}function gameWin() {    clearInterval(timerInterval);    finalTimeEl.textContent = timeEl.textContent;    playSound('win');    modalEl.classList.remove('hidden');}document.getElementById('hint-btn').onclick = () => {    if (hintCount <= 0 || foundCount === wordsToFind.length) return;    const unfoundWords = wordsToFind.filter(w => !w.found);    if (!unfoundWords.length) return;    const targetWord = unfoundWords[Math.floor(Math.random() * unfoundWords.length)].word;        for (let r = 0; r < GRID_SIZE; r++) {        for (let c = 0; c < GRID_SIZE; c++) {            if (grid[r][c] === targetWord[0]) {                const directions = [[0, 1], [0, -1], [1, 0], [1, 1], [1, -1]];                for (let dir of directions) {                    if (canPlace(targetWord, r, c, dir)) {                                                                         let match = true;                        for (let i = 0; i < targetWord.length; i++) {                            if (grid[r + i * dir[0]][c + i * dir[1]] !== targetWord[i]) match = false;                        }                        if (match) {                            const cell = document.querySelector(`.cell[data-r='${r}'][data-c='${c}']`);                            if (!cell.classList.contains('found')) {                                cell.classList.add('hint-highlight');                                setTimeout(() => cell.classList.remove('hint-highlight'), 1000);                                hintCount--;                                updateStats();                                return;                            }                        }                    }                }            }        }    }};document.getElementById('restart-btn').onclick = initGame;document.getElementById('modal-restart').onclick = initGame;document.getElementById('sound-btn').onclick = () => {    soundEnabled = !soundEnabled;    document.getElementById('sound-btn').innerHTML = soundEnabled ? '<i class="fas fa-volume-up"></i>' : '<i class="fas fa-volume-mute"></i>';};initGame();