<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø¹Ø¯Ø§Ø¡ Ø§Ù„Ø³Ø­Ø± - Ù…ØºØ§Ù…Ø±Ø© Ø³Ø§Ø­Ø±Ø©</title>
    <link rel="icon" type="image/x-icon" href="favicon/favicon1.ico">
    <link rel="icon" type="image/png" href="favicon/favicon1.png">
    <link rel="apple-touch-icon" href="favicon/apple-touch-icon1.png">
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Game container */
        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 900px;
            height: 100vh;
            max-height: 600px;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        /* Game canvas */
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        /* UI elements */
        .ui-element {
            position: absolute;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 10;
            user-select: none;
        }

        #score {
            top: 20px;
            right: 20px;
            font-size: 24px;
        }

        #combo {
            top: 20px;
            right: 50%;
            transform: translateX(50%);
            font-size: 20px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #combo.active {
            opacity: 1;
        }

        #highScore {
            top: 20px;
            left: 20px;
            font-size: 18px;
        }

        /* Power-up indicators */
        .power-up-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .power-up-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            opacity: 0.5;
            transition: all 0.3s;
        }

        .power-up-icon.active {
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
        }

        /* Menus */
        .menu {
            position: absolute;
            top: 0;
            right: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s;
        }

        .menu.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .menu h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #FFD700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
            animation: pulse 2s infinite;
        }

        .menu p {
            font-size: 18px;
            margin-bottom: 30px;
            color: #FFF;
            text-align: center;
            max-width: 80%;
        }

        .menu button {
            padding: 15px 30px;
            margin: 10px;
            font-size: 20px;
            font-weight: bold;
            color: white;
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .menu button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .menu button:active {
            transform: translateY(0);
        }

        /* Controls */
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        /* Sound toggle */
        #soundToggle {
            position: absolute;
            top: 20px;
            left: 60px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 10;
        }

        #soundToggle:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Animations */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }

        @keyframes fireworks {
            0% { transform: translateY(0) scale(0); opacity: 1; }
            50% { opacity: 1; }
            100% { transform: translateY(-100px) scale(1); opacity: 0; }
        }

        @keyframes throneGlow {
            0% { filter: drop-shadow(0 0 5px gold); }
            50% { filter: drop-shadow(0 0 20px gold) drop-shadow(0 0 30px orange); }
            100% { filter: drop-shadow(0 0 5px gold); }
        }

        .shake {
            animation: shake 0.5s;
        }

        /* Developer credit */
        #developerCredit {
            position: absolute;
            bottom: 10px;
            right: 50%;
            transform: translateX(50%);
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        /* Win Menu */
        #winMenu {
            background: linear-gradient(135deg, rgba(106, 27, 154, 0.9) 0%, rgba(49, 27, 146, 0.9) 100%);
        }

        #winMenu h1 {
            font-size: 60px;
            color: #FFD700;
            text-shadow: 0 0 20px #FF6B00, 0 0 30px #FF4081;
            animation: pulse 1.5s infinite;
        }

        #winMenu p {
            font-size: 24px;
            color: #E1BEE7;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .throne-container {
            position: relative;
            margin: 20px 0;
        }

        .throne {
            font-size: 80px;
            animation: throneGlow 2s infinite;
            filter: drop-shadow(0 0 10px gold);
        }

        .wizard-on-throne {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            filter: drop-shadow(0 0 5px white);
        }

        .firework {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: fireworks 1.5s ease-out forwards;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .menu h1 {
                font-size: 36px;
            }
            
            .menu p {
                font-size: 16px;
            }
            
            .menu button {
                padding: 12px 24px;
                font-size: 18px;
            }
            
            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }

            #winMenu h1 {
                font-size: 40px;
            }

            .throne {
                font-size: 60px;
            }

            .wizard-on-throne {
                font-size: 30px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- UI Elements -->
        <div id="score" class="ui-element">Ø§Ù„Ù†Ù‚Ø§Ø·: 0</div>
        <div id="combo" class="ui-element">Ù…Ø¶Ø§Ø¹Ù x1</div>
        <div id="highScore" class="ui-element">Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø©: 0</div>
        
        <!-- Power-up indicators -->
        <div class="power-up-indicator">
            <div id="shieldIndicator" class="power-up-icon" title="Ø¯Ø±Ø¹">ğŸ›¡ï¸</div>
            <div id="magnetIndicator" class="power-up-icon" title="Ù…ØºÙ†Ø§Ø·ÙŠØ³">ğŸ§²</div>
            <div id="speedIndicator" class="power-up-icon" title="Ø³Ø±Ø¹Ø© ÙØ§Ø¦Ù‚Ø©">âš¡</div>
            <div id="giantIndicator" class="power-up-icon" title="Ø¹Ù…Ù„Ø§Ù‚">ğŸ¦£</div>
            <div id="freezeIndicator" class="power-up-icon" title="ØªØ¬Ù…ÙŠØ¯ Ø§Ù„ÙˆÙ‚Øª">â„ï¸</div>
        </div>
        
        <!-- Sound toggle -->
        <div id="soundToggle" title="ØªØ´ØºÙŠÙ„/Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØµÙˆØª">ğŸ”Š</div>
        
        <!-- Mobile controls -->
        <div class="controls">
            <div id="jumpBtn" class="control-btn" title="Ù‚ÙØ²">â¬†ï¸</div>
            <div id="dashBtn" class="control-btn" title="Ø§Ù†Ø¯ÙØ§Ø¹">ğŸ’¨</div>
            <div id="attackBtn" class="control-btn" title="Ù‡Ø¬ÙˆÙ…" style="display: none;">ğŸ”¥</div>
        </div>
        
        <!-- Developer credit -->
        <div id="developerCredit">ØªÙ… ØªØ·ÙˆÙŠØ± Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨ÙˆØ§Ø³Ø·Ø© Ø¹Ø¨Ø¯ Ø§Ù„Ù„Ù‡</div>
        
        <!-- Start Menu -->
        <div id="startMenu" class="menu">
            <h1>Ø¹Ø¯Ø§Ø¡ Ø§Ù„Ø³Ø­Ø±</h1>
            <p>Ø§Ù†Ø¶Ù… Ø¥Ù„Ù‰ Ø§Ù„Ø³Ø§Ø­Ø± ÙÙŠ Ù…ØºØ§Ù…Ø±Ø© Ø³Ø§Ø­Ø±Ø©! Ø§Ù‚ÙØ²ØŒ Ø§Ù†Ø¯ÙØ¹ØŒ ÙˆØ¬Ù…Ø¹ Ø§Ù„ÙƒØ±Ø§Øª Ø§Ù„Ø³Ø­Ø±ÙŠØ© Ù„Ù„Ø¨Ù‚Ø§Ø¡!</p>
            <button id="startBtn">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
            <button id="instructionsBtn">ÙƒÙŠÙÙŠØ© Ø§Ù„Ù„Ø¹Ø¨</button>
        </div>
        
        <!-- Instructions Menu -->
        <div id="instructionsMenu" class="menu hidden">
            <h1>ÙƒÙŠÙÙŠØ© Ø§Ù„Ù„Ø¹Ø¨</h1>
            <p>
                <strong>Ø§Ù„Ø­Ø§Ø³ÙˆØ¨:</strong> Ø§Ø³ØªØ®Ø¯Ù… Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø£Ø³Ù‡Ù… Ø£Ùˆ Ø§Ù„Ù…Ø³Ø§ÙØ© Ù„Ù„Ù‚ÙØ²ØŒ Ù…ÙØªØ§Ø­ÙŠ Ø§Ù„Ø£Ø³Ù‡Ù… Ù„Ù„Ù‚ÙØ² Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬ØŒ ÙˆÙ…ÙØªØ§Ø­ Shift Ù„Ù„Ø§Ù†Ø¯ÙØ§Ø¹ØŒ ÙˆÙ…ÙØªØ§Ø­ Control Ù„Ù„Ù‡Ø¬ÙˆÙ… Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø¹ÙŠÙ….<br><br>
                <strong>Ø§Ù„Ù‡Ø§ØªÙ:</strong> Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø© Ù„Ù„Ù‚ÙØ² ÙˆØ§Ù„Ø§Ù†Ø¯ÙØ§Ø¹ ÙˆØ§Ù„Ù‡Ø¬ÙˆÙ….<br><br>
                Ø§Ø¬Ù…Ø¹ Ø§Ù„ÙƒØ±Ø§Øª Ø§Ù„Ø³Ø­Ø±ÙŠØ© Ù„Ø²ÙŠØ§Ø¯Ø© Ù†Ù‚Ø§Ø·Ùƒ! ØªØ¬Ù†Ø¨ Ø§Ù„Ø¹Ù‚Ø¨Ø§Øª ÙˆØ§Ù„Ø£Ø¹Ø¯Ø§Ø¡.<br><br>
                Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‚ÙˆÙ‰ Ø§Ù„Ø®Ø§ØµØ© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù‚Ø¯Ø±Ø§Øª Ø®Ø§ØµØ©. Ø¹Ù†Ø¯Ù…Ø§ ØªØµÙ„ Ø¥Ù„Ù‰ 500 Ù†Ù‚Ø·Ø©ØŒ ÙˆØ§Ø¬Ù‡ Ø§Ù„Ø²Ø¹ÙŠÙ…!
            </p>
            <button id="backBtn">Ø±Ø¬ÙˆØ¹</button>
        </div>
        
        <!-- Pause Menu -->
        <div id="pauseMenu" class="menu hidden">
            <h1>Ø§Ù„Ù„Ø¹Ø¨Ø© Ù…ØªÙˆÙ‚ÙØ©</h1>
            <p>Ø®Ø° Ù‚Ø³Ø·Ù‹Ø§ Ù…Ù† Ø§Ù„Ø±Ø§Ø­Ø©ØŒ Ø£ÙŠÙ‡Ø§ Ø§Ù„Ø³Ø§Ø­Ø± Ø§Ù„Ø´Ø¬Ø§Ø¹!</p>
            <button id="resumeBtn">Ø§Ø³ØªØ¦Ù†Ø§Ù</button>
            <button id="restartBtn">Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„</button>
            <button id="mainMenuBtn">Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
        </div>
        
        <!-- Game Over Menu -->
        <div id="gameOverMenu" class="menu hidden">
            <h1>Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©</h1>
            <p id="finalScore">Ù†Ù‚Ø§Ø·Ùƒ: 0</p>
            <button id="tryAgainBtn">Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰</button>
            <button id="mainMenuBtn2">Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
        </div>

        <!-- Win Menu -->
        <div id="winMenu" class="menu hidden">
            <h1>ğŸ‰ Ø§Ù†ØªØµØ±Øª! ğŸ‰</h1>
            <p>Ù„Ù‚Ø¯ Ù‡Ø²Ù…Øª Ø§Ù„Ø²Ø¹ÙŠÙ… Ø§Ù„Ø´Ø±ÙŠØ± ÙˆØ£Ø¹Ø¯Øª Ø§Ù„Ø³Ù„Ø§Ù… Ø¥Ù„Ù‰ Ø§Ù„Ù…Ù…Ù„ÙƒØ©!</p>
            <div class="throne-container">
                <div class="throne">ğŸª‘</div>
                <div class="wizard-on-throne">ğŸ§™â€â™‚ï¸</div>
            </div>
            <p id="winScore">Ù†Ù‚Ø§Ø·Ùƒ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: 0</p>
            <button id="winRestartBtn">Ø§Ù„Ø¹Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰</button>
            <button id="winMainMenuBtn">Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
        </div>
    </div>

    <script>
        // Game Configuration
        const CONFIG = {
            // Game dimensions
            WIDTH: 900,
            HEIGHT: 600,
            
            // Player properties
            PLAYER: {
                WIDTH: 50,
                HEIGHT: 60,
                JUMP_FORCE: -15,
                GRAVITY: 0.6,
                DASH_FORCE: 20,
                DASH_COOLDOWN: 1000,
                DOUBLE_JUMP_FORCE: -12,
                SPEED: 5,
                INVINCIBLE_DURATION: 2000,
                GIANT_DURATION: 5000,
                GIANT_SCALE: 1.8,
                FLY_DURATION: 3000,
                MAGNET_RANGE: 150,
                ATTACK_COOLDOWN: 100,
                ATTACK_DAMAGE: 1,
                ATTACK_RANGE: 200,
                PROJECTILE_SPEED: 8
            },
            
            // Game properties
            GAME: {
                INITIAL_SPEED: 5,
                SPEED_INCREMENT: 0.001,
                MAX_SPEED: 12,
                OBSTACLE_SPAWN_RATE: 0.02,
                ENEMY_SPAWN_RATE: 0.01,
                ORB_SPAWN_RATE: 0.03,
                POWERUP_SPAWN_RATE: 0.005,
                BOSS_THRESHOLD: 500,
                COMBO_TIME: 2000,
                PARTICLE_COUNT: 3,
                SHAKE_INTENSITY: 5,
                GROUND_HEIGHT: 100
            },
            
            // Visual settings
            VISUAL: {
                PARALLAX_LAYERS: 5,
                PARTICLE_LIFETIME: 60,
                TRAIL_LENGTH: 10,
                GLOW_RADIUS: 15,
                STAR_COUNT: 100
            }
        };

        // Game State
        const GameState = {
            MENU: 'menu',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'game_over',
            BOSS: 'boss',
            WIN: 'win'
        };

        // Power-up Types
        const PowerUpType = {
            SHIELD: 'shield',
            MAGNET: 'magnet',
            SPEED: 'speed',
            GIANT: 'giant',
            FREEZE: 'freeze',
            FLY: 'fly'
        };

        // Main Game Class
        class MagicalRunner {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas();
                
                // Game state
                this.state = GameState.MENU;
                this.score = 0;
                this.highScore = parseInt(localStorage.getItem('magicalRunnerHighScore') || '0');
                this.combo = 0;
                this.comboTimer = 0;
                this.multiplier = 1;
                this.speed = CONFIG.GAME.INITIAL_SPEED;
                this.soundEnabled = true;
                this.shakeAmount = 0;
                this.bossDefeated = false;
                
                // Game objects
                this.player = null;
                this.obstacles = [];
                this.enemies = [];
                this.orbs = [];
                this.powerUps = [];
                this.particles = [];
                this.stars = [];
                this.boss = null;
                this.bossProjectiles = [];
                this.playerProjectiles = [];
                
                // Parallax backgrounds
                this.parallaxLayers = [];
                this.groundOffset = 0;
                
                // Input handling
                this.keys = {};
                this.touchStartX = 0;
                this.touchStartY = 0;
                
                // Initialize
                this.init();
            }
            
            setupCanvas() {
                // Set canvas size
                this.canvas.width = CONFIG.WIDTH;
                this.canvas.height = CONFIG.HEIGHT;
                
                // Scale for high DPI displays
                const dpr = window.devicePixelRatio || 1;
                const rect = this.canvas.getBoundingClientRect();
                
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
            }
            
            init() {
                // Initialize player
                this.player = new Player(
                    CONFIG.WIDTH * 0.2,
                    CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - CONFIG.PLAYER.HEIGHT,
                    CONFIG.PLAYER.WIDTH,
                    CONFIG.PLAYER.HEIGHT
                );
                
                // Initialize stars
                this.initStars();
                
                // Initialize parallax layers
                this.initParallaxLayers();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Update UI
                this.updateUI();
                
                // Start game loop
                this.gameLoop();
            }
            
            initStars() {
                for (let i = 0; i < CONFIG.VISUAL.STAR_COUNT; i++) {
                    this.stars.push({
                        x: Math.random() * CONFIG.WIDTH,
                        y: Math.random() * (CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT),
                        size: Math.random() * 2 + 0.5,
                        speed: Math.random() * 0.5 + 0.1,
                        opacity: Math.random() * 0.8 + 0.2
                    });
                }
            }
            
            initParallaxLayers() {
                const colors = [
                    'rgba(25, 25, 112, 0.2)',  // Midnight blue
                    'rgba(70, 130, 180, 0.3)', // Steel blue
                    'rgba(100, 149, 237, 0.4)', // Cornflower blue
                    'rgba(135, 206, 250, 0.5)', // Light sky blue
                    'rgba(176, 224, 230, 0.6)'  // Powder blue
                ];
                
                for (let i = 0; i < CONFIG.VISUAL.PARALLAX_LAYERS; i++) {
                    this.parallaxLayers.push({
                        y: (CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT) * (i / CONFIG.VISUAL.PARALLAX_LAYERS),
                        height: (CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT) / CONFIG.VISUAL.PARALLAX_LAYERS,
                        color: colors[i],
                        speed: (i + 1) * 0.2,
                        elements: []
                    });
                    
                    // Add random elements to each layer
                    const elementCount = 5 + i * 2;
                    for (let j = 0; j < elementCount; j++) {
                        this.parallaxLayers[i].elements.push({
                            x: Math.random() * CONFIG.WIDTH,
                            width: Math.random() * 100 + 50,
                            height: Math.random() * 30 + 20,
                            type: Math.random() > 0.5 ? 'mountain' : 'tree'
                        });
                    }
                }
            }
            
            setupEventListeners() {
                // Keyboard events
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                    
                    // Prevent default for game keys
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Control'].includes(e.key)) {
                        e.preventDefault();
                    }
                    
                    // Jump - fixed to work during boss battles
                    if ((e.key === ' ' || e.key === 'ArrowUp') && 
                        (this.state === GameState.PLAYING || this.state === GameState.BOSS)) {
                        this.player.jump();
                    }
                    
                    // Dash - fixed to work during boss battles
                    if (e.key === 'Shift' && 
                        (this.state === GameState.PLAYING || this.state === GameState.BOSS)) {
                        this.player.dash();
                    }
                    
                    // Attack - only during boss battles
                    if (e.key === 'Control' && this.state === GameState.BOSS) {
                        this.player.attack();
                    }
                    
                    // Pause - fixed to work during boss battles
                    if (e.key === 'Escape' && 
                        (this.state === GameState.PLAYING || this.state === GameState.BOSS)) {
                        this.pause();
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });
                
                // Touch events
                this.canvas.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    this.touchStartX = touch.clientX;
                    this.touchStartY = touch.clientY;
                });
                
                this.canvas.addEventListener('touchend', (e) => {
                    if (this.state !== GameState.PLAYING && this.state !== GameState.BOSS) return;
                    
                    const touch = e.changedTouches[0];
                    const deltaX = touch.clientX - this.touchStartX;
                    const deltaY = touch.clientY - this.touchStartY;
                    
                    // Determine swipe direction
                    if (Math.abs(deltaY) > Math.abs(deltaX)) {
                        // Vertical swipe - jump
                        if (deltaY < -30) {
                            this.player.jump();
                        }
                    } else {
                        // Horizontal swipe - dash
                        if (Math.abs(deltaX) > 30) {
                            this.player.dash();
                        }
                    }
                });
                
                // Mobile control buttons - fixed to work during boss battles
                document.getElementById('jumpBtn').addEventListener('click', () => {
                    if (this.state === GameState.PLAYING || this.state === GameState.BOSS) {
                        this.player.jump();
                    }
                });
                
                document.getElementById('dashBtn').addEventListener('click', () => {
                    if (this.state === GameState.PLAYING || this.state === GameState.BOSS) {
                        this.player.dash();
                    }
                });
                
                document.getElementById('attackBtn').addEventListener('click', () => {
                    if (this.state === GameState.BOSS) {
                        this.player.attack();
                    }
                });
                
                // Menu buttons
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.start();
                });
                
                document.getElementById('instructionsBtn').addEventListener('click', () => {
                    document.getElementById('startMenu').classList.add('hidden');
                    document.getElementById('instructionsMenu').classList.remove('hidden');
                });
                
                document.getElementById('backBtn').addEventListener('click', () => {
                    document.getElementById('instructionsMenu').classList.add('hidden');
                    document.getElementById('startMenu').classList.remove('hidden');
                });
                
                document.getElementById('resumeBtn').addEventListener('click', () => {
                    this.resume();
                });
                
                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.restart();
                });
                
                document.getElementById('mainMenuBtn').addEventListener('click', () => {
                    this.mainMenu();
                });
                
                document.getElementById('tryAgainBtn').addEventListener('click', () => {
                    this.restart();
                });
                
                document.getElementById('mainMenuBtn2').addEventListener('click', () => {
                    this.mainMenu();
                });
                
                // Win menu buttons
                document.getElementById('winRestartBtn').addEventListener('click', () => {
                    this.restart();
                });
                
                document.getElementById('winMainMenuBtn').addEventListener('click', () => {
                    this.mainMenu();
                });
                
                // Sound toggle
                document.getElementById('soundToggle').addEventListener('click', () => {
                    this.soundEnabled = !this.soundEnabled;
                    document.getElementById('soundToggle').textContent = this.soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
                });
            }
            
            start() {
                document.getElementById('startMenu').classList.add('hidden');
                this.state = GameState.PLAYING;
                this.reset();
            }
            
            pause() {
                if (this.state === GameState.PLAYING || this.state === GameState.BOSS) {
                    this.state = GameState.PAUSED;
                    document.getElementById('pauseMenu').classList.remove('hidden');
                }
            }
            
            resume() {
                if (this.state === GameState.PAUSED) {
                    this.state = this.boss ? GameState.BOSS : GameState.PLAYING;
                    document.getElementById('pauseMenu').classList.add('hidden');
                }
            }
            
            restart() {
                document.getElementById('gameOverMenu').classList.add('hidden');
                document.getElementById('pauseMenu').classList.add('hidden');
                document.getElementById('winMenu').classList.add('hidden');
                this.state = GameState.PLAYING;
                this.reset();
            }
            
            mainMenu() {
                document.getElementById('gameOverMenu').classList.add('hidden');
                document.getElementById('pauseMenu').classList.add('hidden');
                document.getElementById('instructionsMenu').classList.add('hidden');
                document.getElementById('winMenu').classList.add('hidden');
                document.getElementById('startMenu').classList.remove('hidden');
                this.state = GameState.MENU;
                this.reset();
            }
            
            reset() {
                // Reset game state
                this.score = 0;
                this.combo = 0;
                this.comboTimer = 0;
                this.multiplier = 1;
                this.speed = CONFIG.GAME.INITIAL_SPEED;
                this.shakeAmount = 0;
                this.bossDefeated = false;
                
                // Reset player
                this.player.reset(
                    CONFIG.WIDTH * 0.2,
                    CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - CONFIG.PLAYER.HEIGHT
                );
                
                // Clear game objects
                this.obstacles = [];
                this.enemies = [];
                this.orbs = [];
                this.powerUps = [];
                this.particles = [];
                this.boss = null;
                this.bossProjectiles = [];
                this.playerProjectiles = [];
                
                // Hide attack button
                document.getElementById('attackBtn').style.display = 'none';
                
                // Reset background color
                document.body.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                
                // Update UI
                this.updateUI();
            }
            
            gameLoop() {
                // Clear canvas
                this.ctx.clearRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
                
                // Update and render based on game state
                if (this.state === GameState.PLAYING || this.state === GameState.BOSS) {
                    this.update();
                    this.render();
                } else if (this.state === GameState.MENU || this.state === GameState.PAUSED || this.state === GameState.GAME_OVER || this.state === GameState.WIN) {
                    this.renderBackground();
                }
                
                // Continue game loop
                requestAnimationFrame(() => this.gameLoop());
            }
            
            update() {
                // Update game speed
                if (this.state === GameState.PLAYING) {
                    this.speed = Math.min(
                        CONFIG.GAME.INITIAL_SPEED + this.score * CONFIG.GAME.SPEED_INCREMENT,
                        CONFIG.GAME.MAX_SPEED
                    );
                }
                
                // Update player
                this.player.update();
                
                // Update parallax
                this.updateParallax();
                
                // Update stars
                this.updateStars();
                
                // Spawn game objects
                if (this.state === GameState.PLAYING) {
                    this.spawnObjects();
                }
                
                // Update obstacles
                this.updateObstacles();
                
                // Update enemies
                this.updateEnemies();
                
                // Update orbs
                this.updateOrbs();
                
                // Update power-ups
                this.updatePowerUps();
                
                // Update particles
                this.updateParticles();
                
                // Update player projectiles
                this.updatePlayerProjectiles();
                
                // Update boss
                if (this.state === GameState.BOSS) {
                    this.updateBoss();
                }
                
                // Update combo timer
                if (this.comboTimer > 0) {
                    this.comboTimer--;
                    if (this.comboTimer === 0) {
                        this.combo = 0;
                        this.multiplier = 1;
                        document.getElementById('combo').classList.remove('active');
                    }
                }
                
                // Check for boss spawn
                if (this.score >= CONFIG.GAME.BOSS_THRESHOLD && !this.boss && this.state === GameState.PLAYING && !this.bossDefeated) {
                    this.spawnBoss();
                }
                
                // Update screen shake
                if (this.shakeAmount > 0) {
                    this.shakeAmount *= 0.9;
                    if (this.shakeAmount < 0.1) {
                        this.shakeAmount = 0;
                    }
                }
                
                // Update UI
                this.updateUI();
            }
            
            updateParallax() {
                // Update parallax layers
                for (const layer of this.parallaxLayers) {
                    // Update elements
                    for (const element of layer.elements) {
                        element.x -= this.speed * layer.speed;
                        
                        // Reset element position if it goes off screen
                        if (element.x + element.width < 0) {
                            element.x = CONFIG.WIDTH + Math.random() * 200;
                        }
                    }
                }
                
                // Update ground
                this.groundOffset -= this.speed;
                if (this.groundOffset <= -50) {
                    this.groundOffset = 0;
                }
            }
            
            updateStars() {
                for (const star of this.stars) {
                    star.x -= star.speed * this.speed;
                    
                    // Reset star position if it goes off screen
                    if (star.x < 0) {
                        star.x = CONFIG.WIDTH;
                        star.y = Math.random() * (CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT);
                    }
                }
            }
            
            spawnObjects() {
                // Spawn obstacles
                if (Math.random() < CONFIG.GAME.OBSTACLE_SPAWN_RATE) {
                    this.obstacles.push(new Obstacle(
                        CONFIG.WIDTH,
                        CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - 40,
                        40,
                        40,
                        this.speed
                    ));
                }
                
                // Spawn enemies
                if (Math.random() < CONFIG.GAME.ENEMY_SPAWN_RATE) {
                    const y = CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - 100 - Math.random() * 200;
                    this.enemies.push(new Enemy(
                        CONFIG.WIDTH,
                        y,
                        40,
                        40,
                        this.speed
                    ));
                }
                
                // Spawn orbs
                if (Math.random() < CONFIG.GAME.ORB_SPAWN_RATE) {
                    const y = CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - 50 - Math.random() * 250;
                    this.orbs.push(new Orb(
                        CONFIG.WIDTH,
                        y,
                        20,
                        this.speed
                    ));
                }
                
                // Spawn power-ups
                if (Math.random() < CONFIG.GAME.POWERUP_SPAWN_RATE) {
                    const types = Object.values(PowerUpType);
                    const type = types[Math.floor(Math.random() * types.length)];
                    const y = CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - 50 - Math.random() * 250;
                    this.powerUps.push(new PowerUp(
                        CONFIG.WIDTH,
                        y,
                        30,
                        30,
                        type,
                        this.speed
                    ));
                }
            }
            
            updateObstacles() {
                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    const obstacle = this.obstacles[i];
                    obstacle.update();
                    
                    // Check collision with player
                    if (this.checkCollision(this.player, obstacle)) {
                        if (!this.player.invincible) {
                            this.gameOver();
                        } else {
                            // Destroy obstacle if player is invincible
                            this.createExplosion(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
                            this.obstacles.splice(i, 1);
                            continue;
                        }
                    }
                    
                    // Remove if off screen
                    if (obstacle.x + obstacle.width < 0) {
                        this.obstacles.splice(i, 1);
                    }
                }
            }
            
            updateEnemies() {
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    enemy.update();
                    
                    // Check collision with player
                    if (this.checkCollision(this.player, enemy)) {
                        if (!this.player.invincible) {
                            this.gameOver();
                        } else {
                            // Destroy enemy if player is invincible
                            this.createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                            this.enemies.splice(i, 1);
                            continue;
                        }
                    }
                    
                    // Remove if off screen
                    if (enemy.x + enemy.width < 0) {
                        this.enemies.splice(i, 1);
                    }
                }
            }
            
            updateOrbs() {
                for (let i = this.orbs.length - 1; i >= 0; i--) {
                    const orb = this.orbs[i];
                    orb.update();
                    
                    // Check if player has magnet power-up
                    if (this.player.hasPowerUp(PowerUpType.MAGNET)) {
                        const dx = this.player.x + this.player.width / 2 - (orb.x + orb.width / 2);
                        const dy = this.player.y + this.player.height / 2 - (orb.y + orb.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < CONFIG.PLAYER.MAGNET_RANGE) {
                            // Move orb towards player
                            orb.x += dx * 0.1;
                            orb.y += dy * 0.1;
                        }
                    }
                    
                    // Check collision with player
                    if (this.checkCollision(this.player, orb)) {
                        // Collect orb
                        this.collectOrb();
                        this.createCollectEffect(orb.x + orb.width / 2, orb.y + orb.height / 2);
                        this.orbs.splice(i, 1);
                        continue;
                    }
                    
                    // Remove if off screen
                    if (orb.x + orb.width < 0) {
                        this.orbs.splice(i, 1);
                    }
                }
            }
            
            updatePowerUps() {
                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    const powerUp = this.powerUps[i];
                    powerUp.update();
                    
                    // Check collision with player
                    if (this.checkCollision(this.player, powerUp)) {
                        // Activate power-up
                        this.player.activatePowerUp(powerUp.type);
                        this.createPowerUpEffect(powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2, powerUp.type);
                        this.powerUps.splice(i, 1);
                        continue;
                    }
                    
                    // Remove if off screen
                    if (powerUp.x + powerUp.width < 0) {
                        this.powerUps.splice(i, 1);
                    }
                }
            }
            
            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.update();
                    
                    // Remove if lifetime is over
                    if (particle.lifetime <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            updatePlayerProjectiles() {
                for (let i = this.playerProjectiles.length - 1; i >= 0; i--) {
                    const projectile = this.playerProjectiles[i];
                    projectile.update();
                    
                    // Check collision with boss
                    if (this.boss && this.checkCollision(projectile, this.boss)) {
                        this.boss.takeDamage(CONFIG.PLAYER.ATTACK_DAMAGE);
                        this.createHitEffect(projectile.x + projectile.width / 2, projectile.y + projectile.height / 2);
                        this.playerProjectiles.splice(i, 1);
                        continue;
                    }
                    
                    // Remove if off screen
                    if (projectile.x > CONFIG.WIDTH || projectile.y < 0 || projectile.y > CONFIG.HEIGHT) {
                        this.playerProjectiles.splice(i, 1);
                    }
                }
            }
            
            spawnBoss() {
                this.state = GameState.BOSS;
                this.boss = new Boss(
                    CONFIG.WIDTH,
                    CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - 200,
                    100,
                    150,
                    this.speed
                );
                
                // Show attack button
                document.getElementById('attackBtn').style.display = 'flex';
                
                // Screen shake
                this.shakeAmount = CONFIG.GAME.SHAKE_INTENSITY;
                
                // Change background color
                document.body.style.background = 'linear-gradient(135deg, #8B0000 0%, #4B0082 100%)';
            }
            
            updateBoss() {
                if (!this.boss) return;
                
                this.boss.update();
                
                // Check collision with player
                if (this.checkCollision(this.player, this.boss)) {
                    if (!this.player.invincible) {
                        this.gameOver();
                    }
                }
                
                // Update boss projectiles
                for (let i = this.bossProjectiles.length - 1; i >= 0; i--) {
                    const projectile = this.bossProjectiles[i];
                    projectile.update();
                    
                    // Check collision with player
                    if (this.checkCollision(this.player, projectile)) {
                        if (!this.player.invincible) {
                            this.gameOver();
                        } else {
                            // Destroy projectile if player is invincible
                            this.createExplosion(projectile.x + projectile.width / 2, projectile.y + projectile.height / 2);
                            this.bossProjectiles.splice(i, 1);
                            continue;
                        }
                    }
                    
                    // Remove if off screen
                    if (projectile.x + projectile.width < 0 || projectile.y > CONFIG.HEIGHT) {
                        this.bossProjectiles.splice(i, 1);
                    }
                }
                
                // Spawn boss projectiles
                if (Math.random() < 0.02) {
                    this.bossProjectiles.push(new BossProjectile(
                        this.boss.x,
                        this.boss.y + this.boss.height / 2,
                        20,
                        20,
                        -this.speed - 2,
                        this.player
                    ));
                }
                
                // Check if boss is defeated
                if (this.boss.health <= 0) {
                    this.winGame();
                }
            }
            
            checkCollision(obj1, obj2) {
                return obj1.x < obj2.x + obj2.width &&
                       obj1.x + obj1.width > obj2.x &&
                       obj1.y < obj2.y + obj2.height &&
                       obj1.y + obj1.height > obj2.y;
            }
            
            collectOrb() {
                // Update score
                this.score += 10 * this.multiplier;
                
                // Update combo
                this.combo++;
                this.comboTimer = CONFIG.GAME.COMBO_TIME;
                
                // Update multiplier
                if (this.combo > 0 && this.combo % 5 === 0) {
                    this.multiplier = Math.min(this.multiplier + 1, 5);
                }
                
                // Update combo display
                const comboElement = document.getElementById('combo');
                comboElement.textContent = `Ù…Ø¶Ø§Ø¹Ù x${this.multiplier}`;
                comboElement.classList.add('active');
                
                // Play sound
                this.playSound('collect');
                
                // Create particles
                for (let i = 0; i < CONFIG.GAME.PARTICLE_COUNT; i++) {
                    this.particles.push(new Particle(
                        this.player.x + this.player.width / 2,
                        this.player.y + this.player.height / 2,
                        Math.random() * 4 - 2,
                        Math.random() * -4 - 2,
                        'gold'
                    ));
                }
            }
            
            createExplosion(x, y, count = 20) {
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count;
                    const speed = Math.random() * 5 + 2;
                    this.particles.push(new Particle(
                        x,
                        y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        'orange'
                    ));
                }
                
                // Screen shake
                this.shakeAmount = CONFIG.GAME.SHAKE_INTENSITY;
                
                // Play sound
                this.playSound('explosion');
            }
            
            createCollectEffect(x, y) {
                for (let i = 0; i < CONFIG.GAME.PARTICLE_COUNT; i++) {
                    const angle = (Math.PI * 2 * i) / CONFIG.GAME.PARTICLE_COUNT;
                    const speed = Math.random() * 2 + 1;
                    this.particles.push(new Particle(
                        x,
                        y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        'gold'
                    ));
                }
            }
            
            createPowerUpEffect(x, y, type) {
                const colors = {
                    [PowerUpType.SHIELD]: 'blue',
                    [PowerUpType.MAGNET]: 'purple',
                    [PowerUpType.SPEED]: 'yellow',
                    [PowerUpType.GIANT]: 'green',
                    [PowerUpType.FREEZE]: 'cyan',
                    [PowerUpType.FLY]: 'white'
                };
                
                const color = colors[type] || 'white';
                
                for (let i = 0; i < CONFIG.GAME.PARTICLE_COUNT * 2; i++) {
                    const angle = (Math.PI * 2 * i) / (CONFIG.GAME.PARTICLE_COUNT * 2);
                    const speed = Math.random() * 3 + 1;
                    this.particles.push(new Particle(
                        x,
                        y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        color
                    ));
                }
                
                // Play sound
                this.playSound('powerup');
            }
            
            createAttackEffect(x, y) {
                for (let i = 0; i < 15; i++) {
                    const angle = (Math.PI * 2 * i) / 15;
                    const speed = Math.random() * 3 + 2;
                    this.particles.push(new Particle(
                        x,
                        y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        'red'
                    ));
                }
            }
            
            createHitEffect(x, y) {
                for (let i = 0; i < 20; i++) {
                    const angle = (Math.PI * 2 * i) / 20;
                    const speed = Math.random() * 4 + 3;
                    this.particles.push(new Particle(
                        x,
                        y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        'yellow'
                    ));
                }
                this.playSound('hit');
            }
            
            createFireworks() {
                for (let i = 0; i < 30; i++) {
                    const firework = document.createElement('div');
                    firework.className = 'firework';
                    firework.style.left = Math.random() * 100 + 'vw';
                    firework.style.backgroundColor = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'][Math.floor(Math.random() * 6)];
                    firework.style.animationDelay = Math.random() * 2 + 's';
                    document.getElementById('winMenu').appendChild(firework);
                    
                    // Remove after animation
                    setTimeout(() => {
                        if (firework.parentNode) {
                            firework.parentNode.removeChild(firework);
                        }
                    }, 3000);
                }
            }
            
            gameOver() {
                this.state = GameState.GAME_OVER;
                
                // Hide attack button
                document.getElementById('attackBtn').style.display = 'none';
                
                // Update high score
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('magicalRunnerHighScore', this.highScore.toString());
                }
                
                // Show game over menu
                document.getElementById('finalScore').textContent = `Ù†Ù‚Ø§Ø·Ùƒ: ${this.score}`;
                document.getElementById('gameOverMenu').classList.remove('hidden');
                
                // Play sound
                this.playSound('gameover');
                
                // Screen shake
                this.shakeAmount = CONFIG.GAME.SHAKE_INTENSITY;
            }
            
            winGame() {
                this.state = GameState.WIN;
                this.bossDefeated = true;
                
                // Create massive explosion
                this.createExplosion(this.boss.x + this.boss.width / 2, this.boss.y + this.boss.height / 2, 100);
                
                // Hide attack button
                document.getElementById('attackBtn').style.display = 'none';
                
                // Update high score
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('magicalRunnerHighScore', this.highScore.toString());
                }
                
                // Show win menu
                document.getElementById('winScore').textContent = `Ù†Ù‚Ø§Ø·Ùƒ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: ${this.score}`;
                document.getElementById('winMenu').classList.remove('hidden');
                
                // Create fireworks
                this.createFireworks();
                setInterval(() => this.createFireworks(), 2000);
                
                // Play victory sound
                this.playSound('victory');
                
                // Massive screen shake
                this.shakeAmount = CONFIG.GAME.SHAKE_INTENSITY * 3;
                
                // Clear game objects
                this.boss = null;
                this.bossProjectiles = [];
                this.obstacles = [];
                this.enemies = [];
                this.orbs = [];
                this.powerUps = [];
            }
            
            updateUI() {
                document.getElementById('score').textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${this.score}`;
                document.getElementById('highScore').textContent = `Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø©: ${this.highScore}`;
                
                // Update power-up indicators
                document.getElementById('shieldIndicator').classList.toggle('active', this.player.hasPowerUp(PowerUpType.SHIELD));
                document.getElementById('magnetIndicator').classList.toggle('active', this.player.hasPowerUp(PowerUpType.MAGNET));
                document.getElementById('speedIndicator').classList.toggle('active', this.player.hasPowerUp(PowerUpType.SPEED));
                document.getElementById('giantIndicator').classList.toggle('active', this.player.hasPowerUp(PowerUpType.GIANT));
                document.getElementById('freezeIndicator').classList.toggle('active', this.player.hasPowerUp(PowerUpType.FREEZE));
            }
            
            render() {
                // Apply screen shake
                if (this.shakeAmount > 0) {
                    const shakeX = (Math.random() - 0.5) * this.shakeAmount;
                    const shakeY = (Math.random() - 0.5) * this.shakeAmount;
                    this.ctx.save();
                    this.ctx.translate(shakeX, shakeY);
                }
                
                // Render background
                this.renderBackground();
                
                // Render game objects
                this.renderOrbs();
                this.renderPowerUps();
                this.renderObstacles();
                this.renderEnemies();
                this.renderBoss();
                this.renderBossProjectiles();
                this.renderPlayerProjectiles();
                this.renderPlayer();
                this.renderParticles();
                
                // Reset transform
                if (this.shakeAmount > 0) {
                    this.ctx.restore();
                }
            }
            
            renderBackground() {
                // Sky gradient
                const gradient = this.ctx.createLinearGradient(0, 0, 0, CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT);
                gradient.addColorStop(0, '#0a0e27');
                gradient.addColorStop(1, '#2a3990');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT);
                
                // Stars
                this.ctx.fillStyle = 'white';
                for (const star of this.stars) {
                    this.ctx.globalAlpha = star.opacity;
                    this.ctx.beginPath();
                    this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.globalAlpha = 1;
                
                // Parallax layers
                for (const layer of this.parallaxLayers) {
                    this.ctx.fillStyle = layer.color;
                    
                    for (const element of layer.elements) {
                        if (element.type === 'mountain') {
                            // Draw mountain
                            this.ctx.beginPath();
                            this.ctx.moveTo(element.x, layer.y + layer.height);
                            this.ctx.lineTo(element.x + element.width / 2, layer.y);
                            this.ctx.lineTo(element.x + element.width, layer.y + layer.height);
                            this.ctx.closePath();
                            this.ctx.fill();
                        } else {
                            // Draw tree
                            this.ctx.fillRect(element.x + element.width * 0.4, layer.y + layer.height * 0.5, element.width * 0.2, layer.height * 0.5);
                            this.ctx.beginPath();
                            this.ctx.moveTo(element.x, layer.y + layer.height * 0.5);
                            this.ctx.lineTo(element.x + element.width / 2, layer.y);
                            this.ctx.lineTo(element.x + element.width, layer.y + layer.height * 0.5);
                            this.ctx.closePath();
                            this.ctx.fill();
                        }
                    }
                }
                
                // Ground
                this.ctx.fillStyle = '#3a3a3a';
                this.ctx.fillRect(0, CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT, CONFIG.WIDTH, CONFIG.GAME.GROUND_HEIGHT);
                
                // Ground pattern
                this.ctx.strokeStyle = '#2a2a2a';
                this.ctx.lineWidth = 2;
                for (let i = this.groundOffset; i < CONFIG.WIDTH; i += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT);
                    this.ctx.lineTo(i, CONFIG.HEIGHT);
                    this.ctx.stroke();
                }
            }
            
            renderPlayer() {
                this.ctx.save();
                
                // Apply transformations
                this.ctx.translate(this.player.x + this.player.width / 2, this.player.y + this.player.height / 2);
                
                // Apply scale if giant power-up is active
                if (this.player.hasPowerUp(PowerUpType.GIANT)) {
                    this.ctx.scale(CONFIG.PLAYER.GIANT_SCALE, CONFIG.PLAYER.GIANT_SCALE);
                }
                
                // Apply rotation if dashing
                if (this.player.dashing) {
                    this.ctx.rotate(Math.PI / 4);
                }
                
                // Draw wizard body
                this.ctx.fillStyle = '#4a148c';
                this.ctx.fillRect(-this.player.width / 2, -this.player.height / 2, this.player.width, this.player.height * 0.7);
                
                // Draw wizard hat
                this.ctx.fillStyle = '#311b92';
                this.ctx.beginPath();
                this.ctx.moveTo(-this.player.width / 2, -this.player.height / 2);
                this.ctx.lineTo(0, -this.player.height);
                this.ctx.lineTo(this.player.width / 2, -this.player.height / 2);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Draw wizard face
                this.ctx.fillStyle = '#ffdbac';
                this.ctx.fillRect(-this.player.width / 3, -this.player.height / 3, this.player.width * 2/3, this.player.height / 4);
                
                // Draw eyes
                this.ctx.fillStyle = 'white';
                this.ctx.fillRect(-this.player.width / 3, -this.player.height / 3, this.player.width / 6, this.player.height / 12);
                this.ctx.fillRect(this.player.width / 6, -this.player.height / 3, this.player.width / 6, this.player.height / 12);
                
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(-this.player.width / 3, -this.player.height / 3, this.player.width / 12, this.player.height / 12);
                this.ctx.fillRect(this.player.width / 4, -this.player.height / 3, this.player.width / 12, this.player.height / 12);
                
                // Draw beard
                this.ctx.fillStyle = 'white';
                this.ctx.fillRect(-this.player.width / 4, -this.player.height / 6, this.player.width / 2, this.player.height / 6);
                
                // Draw wand
                this.ctx.strokeStyle = '#8d6e63';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.width / 2, -this.player.height / 4);
                this.ctx.lineTo(this.player.width, -this.player.height / 2);
                this.ctx.stroke();
                
                // Draw wand star
                this.ctx.fillStyle = '#ffd700';
                this.ctx.beginPath();
                this.ctx.arc(this.player.width, -this.player.height / 2, 5, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw attack effect if attacking
                if (this.player.attacking) {
                    this.ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.arc(this.player.width, 0, CONFIG.PLAYER.ATTACK_RANGE / 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Draw shield if active
                if (this.player.hasPowerUp(PowerUpType.SHIELD)) {
                    this.ctx.strokeStyle = 'rgba(0, 150, 255, 0.5)';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, this.player.width, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                // Draw magnet field if active
                if (this.player.hasPowerUp(PowerUpType.MAGNET)) {
                    this.ctx.strokeStyle = 'rgba(150, 0, 255, 0.3)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, CONFIG.PLAYER.MAGNET_RANGE, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
                
                // Draw trail if dashing
                if (this.player.dashing) {
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    for (let i = 0; i < CONFIG.VISUAL.TRAIL_LENGTH; i++) {
                        const alpha = 0.5 - (i / CONFIG.VISUAL.TRAIL_LENGTH) * 0.5;
                        this.ctx.globalAlpha = alpha;
                        this.ctx.fillRect(-this.player.width / 2 - i * 5, -this.player.height / 2, this.player.width, this.player.height * 0.7);
                    }
                    this.ctx.globalAlpha = 1;
                }
                
                this.ctx.restore();
            }
            
            renderPlayerProjectiles() {
                for (const projectile of this.playerProjectiles) {
                    // Draw projectile
                    this.ctx.fillStyle = '#ffff00';
                    this.ctx.beginPath();
                    this.ctx.arc(projectile.x + projectile.width / 2, projectile.y + projectile.height / 2, projectile.width / 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw projectile glow
                    const gradient = this.ctx.createRadialGradient(
                        projectile.x + projectile.width / 2,
                        projectile.y + projectile.height / 2,
                        0,
                        projectile.x + projectile.width / 2,
                        projectile.y + projectile.height / 2,
                        projectile.width
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(projectile.x + projectile.width / 2, projectile.y + projectile.height / 2, projectile.width, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            renderObstacles() {
                for (const obstacle of this.obstacles) {
                    // Draw obstacle
                    this.ctx.fillStyle = '#795548';
                    this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    
                    // Draw spikes
                    this.ctx.fillStyle = '#4e342e';
                    this.ctx.beginPath();
                    this.ctx.moveTo(obstacle.x, obstacle.y);
                    this.ctx.lineTo(obstacle.x + obstacle.width / 2, obstacle.y - 10);
                    this.ctx.lineTo(obstacle.x + obstacle.width, obstacle.y);
                    this.ctx.closePath();
                    this.ctx.fill();
                }
            }
            
            renderEnemies() {
                for (const enemy of this.enemies) {
                    this.ctx.save();
                    
                    // Apply transformations
                    this.ctx.translate(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                    
                    // Draw enemy body
                    this.ctx.fillStyle = '#d32f2f';
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, enemy.width / 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw enemy eyes
                    this.ctx.fillStyle = 'white';
                    this.ctx.beginPath();
                    this.ctx.arc(-enemy.width / 4, -enemy.height / 4, enemy.width / 8, 0, Math.PI * 2);
                    this.ctx.arc(enemy.width / 4, -enemy.height / 4, enemy.width / 8, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = 'black';
                    this.ctx.beginPath();
                    this.ctx.arc(-enemy.width / 4, -enemy.height / 4, enemy.width / 16, 0, Math.PI * 2);
                    this.ctx.arc(enemy.width / 4, -enemy.height / 4, enemy.width / 16, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw enemy wings
                    this.ctx.fillStyle = 'rgba(211, 47, 47, 0.7)';
                    const wingFlap = Math.sin(Date.now() * 0.01) * 10;
                    this.ctx.beginPath();
                    this.ctx.moveTo(-enemy.width / 2, 0);
                    this.ctx.lineTo(-enemy.width, -wingFlap);
                    this.ctx.lineTo(-enemy.width / 2, enemy.height / 2);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(enemy.width / 2, 0);
                    this.ctx.lineTo(enemy.width, -wingFlap);
                    this.ctx.lineTo(enemy.width / 2, enemy.height / 2);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            renderOrbs() {
                for (const orb of this.orbs) {
                    this.ctx.save();
                    
                    // Apply transformations
                    this.ctx.translate(orb.x + orb.width / 2, orb.y + orb.height / 2);
                    this.ctx.rotate(Date.now() * 0.005);
                    
                    // Draw orb glow
                    const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, orb.width);
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 1)');
                    gradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.5)');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, orb.width, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw orb core
                    this.ctx.fillStyle = '#ffd700';
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, orb.width / 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw star inside orb
                    this.ctx.fillStyle = '#fff';
                    this.ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
                        const x = Math.cos(angle) * orb.width / 4;
                        const y = Math.sin(angle) * orb.width / 4;
                        
                        if (i === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                        
                        const innerAngle = angle + Math.PI / 5;
                        const innerX = Math.cos(innerAngle) * orb.width / 8;
                        const innerY = Math.sin(innerAngle) * orb.width / 8;
                        this.ctx.lineTo(innerX, innerY);
                    }
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            renderPowerUps() {
                for (const powerUp of this.powerUps) {
                    this.ctx.save();
                    
                    // Apply transformations
                    this.ctx.translate(powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2);
                    this.ctx.rotate(Date.now() * 0.003);
                    
                    // Draw power-up glow
                    const colors = {
                        [PowerUpType.SHIELD]: 'rgba(0, 150, 255, 0.5)',
                        [PowerUpType.MAGNET]: 'rgba(150, 0, 255, 0.5)',
                        [PowerUpType.SPEED]: 'rgba(255, 200, 0, 0.5)',
                        [PowerUpType.GIANT]: 'rgba(0, 200, 0, 0.5)',
                        [PowerUpType.FREEZE]: 'rgba(0, 200, 255, 0.5)',
                        [PowerUpType.FLY]: 'rgba(255, 255, 255, 0.5)'
                    };
                    
                    const color = colors[powerUp.type] || 'rgba(255, 255, 255, 0.5)';
                    
                    const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, powerUp.width);
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, powerUp.width, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw power-up icon
                    this.ctx.font = `${powerUp.width}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    const icons = {
                        [PowerUpType.SHIELD]: 'ğŸ›¡ï¸',
                        [PowerUpType.MAGNET]: 'ğŸ§²',
                        [PowerUpType.SPEED]: 'âš¡',
                        [PowerUpType.GIANT]: 'ğŸ¦£',
                        [PowerUpType.FREEZE]: 'â„ï¸',
                        [PowerUpType.FLY]: 'ğŸ¦…'
                    };
                    
                    this.ctx.fillText(icons[powerUp.type] || '?', 0, 0);
                    
                    this.ctx.restore();
                }
            }
            
            renderBoss() {
                if (!this.boss) return;
                
                this.ctx.save();
                
                // Apply transformations
                this.ctx.translate(this.boss.x + this.boss.width / 2, this.boss.y + this.boss.height / 2);
                
                // Draw boss body
                this.ctx.fillStyle = '#8b0000';
                this.ctx.fillRect(-this.boss.width / 2, -this.boss.height / 2, this.boss.width, this.boss.height * 0.7);
                
                // Draw boss head
                this.ctx.fillStyle = '#a52a2a';
                this.ctx.beginPath();
                this.ctx.arc(0, -this.boss.height / 2, this.boss.width / 2, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw boss eyes
                this.ctx.fillStyle = 'red';
                this.ctx.beginPath();
                this.ctx.arc(-this.boss.width / 4, -this.boss.height / 2, this.boss.width / 8, 0, Math.PI * 2);
                this.ctx.arc(this.boss.width / 4, -this.boss.height / 2, this.boss.width / 8, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw boss horns
                this.ctx.fillStyle = '#4b0082';
                this.ctx.beginPath();
                this.ctx.moveTo(-this.boss.width / 2, -this.boss.height / 2);
                this.ctx.lineTo(-this.boss.width / 2 - 20, -this.boss.height);
                this.ctx.lineTo(-this.boss.width / 3, -this.boss.height / 2);
                this.ctx.closePath();
                this.ctx.fill();
                
                this.ctx.beginPath();
                this.ctx.moveTo(this.boss.width / 2, -this.boss.height / 2);
                this.ctx.lineTo(this.boss.width / 2 + 20, -this.boss.height);
                this.ctx.lineTo(this.boss.width / 3, -this.boss.height / 2);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Draw boss arms
                this.ctx.fillStyle = '#8b0000';
                const armSwing = Math.sin(Date.now() * 0.005) * 20;
                
                this.ctx.save();
                this.ctx.rotate(armSwing * Math.PI / 180);
                this.ctx.fillRect(-this.boss.width / 2 - 20, -this.boss.height / 4, 20, this.boss.height / 2);
                this.ctx.restore();
                
                this.ctx.save();
                this.ctx.rotate(-armSwing * Math.PI / 180);
                this.ctx.fillRect(this.boss.width / 2, -this.boss.height / 4, 20, this.boss.height / 2);
                this.ctx.restore();
                
                // Draw boss health bar
                this.ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                this.ctx.fillRect(-this.boss.width / 2, -this.boss.height - 30, this.boss.width, 10);
                
                this.ctx.fillStyle = 'red';
                this.ctx.fillRect(-this.boss.width / 2, -this.boss.height - 30, this.boss.width * (this.boss.health / this.boss.maxHealth), 10);
                
                this.ctx.restore();
            }
            
            renderBossProjectiles() {
                for (const projectile of this.bossProjectiles) {
                    // Draw projectile
                    this.ctx.fillStyle = '#ff4500';
                    this.ctx.beginPath();
                    this.ctx.arc(projectile.x + projectile.width / 2, projectile.y + projectile.height / 2, projectile.width / 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw projectile glow
                    const gradient = this.ctx.createRadialGradient(
                        projectile.x + projectile.width / 2,
                        projectile.y + projectile.height / 2,
                        0,
                        projectile.x + projectile.width / 2,
                        projectile.y + projectile.height / 2,
                        projectile.width
                    );
                    gradient.addColorStop(0, 'rgba(255, 69, 0, 0.5)');
                    gradient.addColorStop(1, 'rgba(255, 69, 0, 0)');
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(projectile.x + projectile.width / 2, projectile.y + projectile.height / 2, projectile.width, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            renderParticles() {
                for (const particle of this.particles) {
                    this.ctx.fillStyle = particle.color;
                    this.ctx.globalAlpha = particle.lifetime / CONFIG.VISUAL.PARTICLE_LIFETIME;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.globalAlpha = 1;
            }
            
            playSound(type) {
                if (!this.soundEnabled) return;
                
                // Create audio context
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create oscillator
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                // Connect nodes
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Set sound parameters based on type
                switch (type) {
                    case 'jump':
                        oscillator.frequency.value = 400;
                        oscillator.type = 'sine';
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                        
                    case 'collect':
                        oscillator.frequency.value = 800;
                        oscillator.type = 'sine';
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.1);
                        break;
                        
                    case 'powerup':
                        oscillator.frequency.value = 600;
                        oscillator.type = 'square';
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                        
                    case 'explosion':
                        oscillator.frequency.value = 100;
                        oscillator.type = 'sawtooth';
                        gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                        
                    case 'gameover':
                        oscillator.frequency.value = 200;
                        oscillator.type = 'sine';
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.5);
                        break;
                        
                    case 'attack':
                        oscillator.frequency.value = 300;
                        oscillator.type = 'sawtooth';
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;

                    case 'hit':
                        oscillator.frequency.value = 150;
                        oscillator.type = 'square';
                        gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.1);
                        break;

                    case 'victory':
                        // Victory fanfare
                        const frequencies = [523, 659, 784, 1047];
                        let startTime = audioContext.currentTime;
                        
                        frequencies.forEach((freq, index) => {
                            const osc = audioContext.createOscillator();
                            const gain = audioContext.createGain();
                            osc.connect(gain);
                            gain.connect(audioContext.destination);
                            
                            osc.frequency.value = freq;
                            osc.type = 'sine';
                            gain.gain.setValueAtTime(0.3, startTime + index * 0.2);
                            gain.gain.exponentialRampToValueAtTime(0.01, startTime + index * 0.2 + 0.5);
                            
                            osc.start(startTime + index * 0.2);
                            osc.stop(startTime + index * 0.2 + 0.5);
                        });
                        break;
                }
            }
        }

        // Player Class
        class Player {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.velocityY = 0;
                this.velocityX = 0;
                this.jumping = false;
                this.doubleJump = false;
                this.dashing = false;
                this.dashCooldown = 0;
                this.invincible = false;
                this.invincibleTimer = 0;
                this.powerUps = {};
                this.flying = false;
                this.flyTimer = 0;
                this.trail = [];
                this.attacking = false;
                this.attackCooldown = 0;
                this.attackTimer = 0;
            }
            
            update() {
    // Apply gravity (only if not flying)
    if (!this.flying) {
        this.velocityY += CONFIG.PLAYER.GRAVITY;
    } else {
        // Flying mode - controlled by player
        // Apply slight downward force when not pressing jump
        this.velocityY *= 0.9; // Air resistance
        
        // Allow player to control flight with jump button
        if (game.keys[' '] || game.keys['ArrowUp']) {
            this.velocityY = -5; // Fly upward when jump is pressed
        } else {
            this.velocityY += 0.2; // Slowly descend when not pressing jump
        }
    }
    
    // Update position
    this.y += this.velocityY;
    this.x += this.velocityX;
    
    // Ground collision (only if not flying)
    if (!this.flying && this.y > CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - this.height) {
        this.y = CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - this.height;
        this.velocityY = 0;
        this.jumping = false;
        this.doubleJump = false;
    }
                
                // Keep player on screen
                if (this.x < 0) {
                    this.x = 0;
                }
                
                // Update dash
                if (this.dashing) {
                    this.velocityX *= 0.9;
                    if (Math.abs(this.velocityX) < 1) {
                        this.dashing = false;
                        this.velocityX = 0;
                    }
                }
                
                // Update dash cooldown
                if (this.dashCooldown > 0) {
                    this.dashCooldown--;
                }
                
                // Update attack
                if (this.attacking) {
                    this.attackTimer--;
                    if (this.attackTimer <= 0) {
                        this.attacking = false;
                    }
                }
                
                // Update attack cooldown
                if (this.attackCooldown > 0) {
                    this.attackCooldown--;
                }
                
                // Update invincibility
                if (this.invincibleTimer > 0) {
                    this.invincibleTimer--;
                    if (this.invincibleTimer === 0) {
                        this.invincible = false;
                    }
                }
                
                // Update power-ups
for (const type in this.powerUps) {
    if (this.powerUps[type] > 0) {
        this.powerUps[type]--;
        
        if (this.powerUps[type] === 0) {
            // Deactivate power-up
            switch (type) {
                case PowerUpType.SPEED:
                    // Speed will be handled by the game
                    break;
                case PowerUpType.GIANT:
                    // Size will be handled by the rendering
                    break;
                case PowerUpType.FLY:
                    this.flying = false;
                    // Give a small upward boost when flight ends to prevent falling too fast
                    this.velocityY = -3;
                    break;
            }
        }
    }
}
                
                // Update fly timer
                if (this.flyTimer > 0) {
                    this.flyTimer--;
                    if (this.flyTimer === 0) {
                        this.flying = false;
                    }
                }
                
                // Update trail
                if (this.dashing) {
                    this.trail.push({
                        x: this.x,
                        y: this.y,
                        width: this.width,
                        height: this.height
                    });
                    
                    if (this.trail.length > CONFIG.VISUAL.TRAIL_LENGTH) {
                        this.trail.shift();
                    }
                } else {
                    this.trail = [];
                }
            }
            
            jump() {
                if (!this.jumping) {
                    // First jump
                    this.velocityY = CONFIG.PLAYER.JUMP_FORCE;
                    this.jumping = true;
                    game.playSound('jump');
                } else if (!this.doubleJump && !this.flying) {
                    // Double jump
                    this.velocityY = CONFIG.PLAYER.DOUBLE_JUMP_FORCE;
                    this.doubleJump = true;
                    game.playSound('jump');
                }
            }
            
            dash() {
                if (this.dashCooldown === 0 && !this.dashing) {
                    this.dashing = true;
                    this.velocityX = CONFIG.PLAYER.DASH_FORCE;
                    this.dashCooldown = CONFIG.PLAYER.DASH_COOLDOWN;
                    game.playSound('jump');
                }
            }
            
            attack() {
                if (this.attackCooldown === 0 && !this.attacking) {
                    this.attacking = true;
                    this.attackTimer = 10; // Attack animation duration
                    this.attackCooldown = CONFIG.PLAYER.ATTACK_COOLDOWN;
                    game.playSound('attack');
                    
                    // Create attack effect
                    game.createAttackEffect(this.x + this.width, this.y + this.height / 2);
                    
                    // Create projectile
                    game.playerProjectiles.push(new PlayerProjectile(
                        this.x + this.width,
                        this.y + this.height / 2 - 10,
                        15,
                        15,
                        CONFIG.PLAYER.PROJECTILE_SPEED
                    ));
                }
            }
            
            activatePowerUp(type) {
                const durations = {
                    [PowerUpType.SHIELD]: CONFIG.PLAYER.INVINCIBLE_DURATION,
                    [PowerUpType.MAGNET]: CONFIG.PLAYER.INVINCIBLE_DURATION * 2,
                    [PowerUpType.SPEED]: CONFIG.PLAYER.INVINCIBLE_DURATION,
                    [PowerUpType.GIANT]: CONFIG.PLAYER.GIANT_DURATION,
                    [PowerUpType.FREEZE]: CONFIG.PLAYER.INVINCIBLE_DURATION,
                    [PowerUpType.FLY]: CONFIG.PLAYER.FLY_DURATION
                };
                
                this.powerUps[type] = durations[type] || CONFIG.PLAYER.INVINCIBLE_DURATION;
                
                // Apply immediate effects
                switch (type) {
                    case PowerUpType.SHIELD:
                        this.invincible = true;
                        this.invincibleTimer = Number.MAX_SAFE_INTEGER;
                        break;
                    case PowerUpType.FLY:
                        this.flying = true;
                        this.flyTimer = durations[type];
                        break;
                }
            }
            
            hasPowerUp(type) {
                return this.powerUps[type] > 0;
            }
            
            reset(x, y) {
                this.x = x;
                this.y = y;
                this.velocityY = 0;
                this.velocityX = 0;
                this.jumping = false;
                this.doubleJump = false;
                this.dashing = false;
                this.dashCooldown = 0;
                this.invincible = false;
                this.invincibleTimer = 0;
                this.powerUps = {};
                this.flying = false;
                this.flyTimer = 0;
                this.trail = [];
                this.attacking = false;
                this.attackCooldown = 0;
                this.attackTimer = 0;
            }
        }

        // Player Projectile Class
        class PlayerProjectile {
            constructor(x, y, width, height, speed) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed;
            }
            
            update() {
                this.x += this.speed;
            }
        }

        // Obstacle Class
        class Obstacle {
            constructor(x, y, width, height, speed) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed;
            }
            
            update() {
                this.x -= this.speed;
            }
        }

        // Enemy Class
        class Enemy {
            constructor(x, y, width, height, speed) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed;
                this.amplitude = 50;
                this.frequency = 0.05;
                this.phase = Math.random() * Math.PI * 2;
                this.baseY = y;
            }
            
            update() {
                this.x -= this.speed;
                
                // Sine wave movement
                this.y = this.baseY + Math.sin(Date.now() * this.frequency + this.phase) * this.amplitude;
            }
        }

        // Orb Class
        class Orb {
            constructor(x, y, radius, speed) {
                this.x = x;
                this.y = y;
                this.width = radius;
                this.height = radius;
                this.speed = speed;
                this.rotation = 0;
                this.floatOffset = Math.random() * Math.PI * 2;
            }
            
            update() {
                this.x -= this.speed;
                this.rotation += 0.05;
                
                // Float up and down
                this.y += Math.sin(Date.now() * 0.005 + this.floatOffset) * 0.5;
            }
        }

        // PowerUp Class
        class PowerUp {
            constructor(x, y, width, height, type, speed) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.speed = speed;
                this.rotation = 0;
                this.floatOffset = Math.random() * Math.PI * 2;
            }
            
            update() {
                this.x -= this.speed;
                this.rotation += 0.03;
                
                // Float up and down
                this.y += Math.sin(Date.now() * 0.005 + this.floatOffset) * 0.5;
            }
        }

        // Boss Class
        class Boss {
            constructor(x, y, width, height, speed) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed;
                this.health = 10;
                this.maxHealth = 10;
                this.attackCooldown = 4;
                this.movePattern = 0;
                this.moveTimer = 0;
            }
            
            update() {
                // Movement pattern
                this.moveTimer++;
                
                if (this.moveTimer > 100) {
                    this.moveTimer = 0;
                    this.movePattern = (this.movePattern + 1) % 3;
                }
                
                switch (this.movePattern) {
                    case 0:
                        // Move left and right
                        this.x += Math.sin(Date.now() * 0.002) * 2;
                        break;
                    case 1:
                        // Move up and down
                        this.y += Math.sin(Date.now() * 0.003) * 3;
                        break;
                    case 2:
                        // Circular motion
                        this.x += Math.cos(Date.now() * 0.002) * 2;
                        this.y += Math.sin(Date.now() * 0.002) * 2;
                        break;
                }
                
                // Keep boss on screen
                if (this.x < CONFIG.WIDTH - this.width * 2) {
                    this.x = CONFIG.WIDTH - this.width * 2;
                }
                if (this.x > CONFIG.WIDTH - this.width) {
                    this.x = CONFIG.WIDTH - this.width;
                }
                if (this.y < 50) {
                    this.y = 50;
                }
                if (this.y > CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - this.height) {
                    this.y = CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - this.height;
                }
                
                // Update attack cooldown
                if (this.attackCooldown > 0) {
                    this.attackCooldown--;
                }
            }
            
            takeDamage(amount) {
                this.health -= amount;
                if (this.health < 0) {
                    this.health = 0;
                }
            }
        }

        // Boss Projectile Class
        class BossProjectile {
            constructor(x, y, width, height, speedX, target) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speedX = speedX;
                this.speedY = 0;
                
                // Calculate angle to target
                const dx = target.x + target.width / 2 - x;
                const dy = target.y + target.height / 2 - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                this.speedX = (dx / distance) * 5;
                this.speedY = (dy / distance) * 5;
            }
            
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
            }
        }

        // Particle Class
        class Particle {
            constructor(x, y, velocityX, velocityY, color) {
                this.x = x;
                this.y = y;
                this.velocityX = velocityX;
                this.velocityY = velocityY;
                this.color = color;
                this.size = Math.random() * 5 + 2;
                this.lifetime = CONFIG.VISUAL.PARTICLE_LIFETIME;
            }
            
            update() {
                this.x += this.velocityX;
                this.y += this.velocityY;
                this.velocityY += 0.2; // Gravity
                this.lifetime--;
            }
        }

        // Initialize game
        const game = new MagicalRunner();

        // Teacher Control Panel
        window.superGame = {
            start: () => game.start(),
            pause: () => game.pause(),
            resume: () => game.resume(),
            restart: () => game.restart(),
            setInvincible: (value) => {
                game.player.invincible = value;
                if (value) {
                    game.player.invincibleTimer = Number.MAX_SAFE_INTEGER;
                } else {
                    game.player.invincibleTimer = 0;
                }
            },
            spawnBoss: () => game.spawnBoss(),
            givePowerUp: (type) => {
                if (Object.values(PowerUpType).includes(type)) {
                    game.player.activatePowerUp(type);
                }
            },
            setSpeedMultiplier: (n) => {
                game.speed = CONFIG.GAME.INITIAL_SPEED * n;
            },
            getScore: () => game.score,
            setScore: (score) => {
                game.score = score;
                game.updateUI();
            },
            getHighScore: () => game.highScore,
            setHighScore: (score) => {
                game.highScore = score;
                localStorage.setItem('magicalRunnerHighScore', score.toString());
                game.updateUI();
            }
        };
    </script>
</body>
</html>