<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø¹Ø¯Ø§Ø¡ Ø§Ù„Ø³Ø­Ø± - Ù…ØºØ§Ù…Ø±Ø© Ø³Ø§Ø­Ø±Ø©</title>
    <link rel="icon" type="image/x-icon" href="data:image/x-icon;base64,">
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Game container */
        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 900px;
            height: 100vh;
            max-height: 600px;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        /* Game canvas */
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        /* UI elements */
        .ui-element {
            position: absolute;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 10;
            user-select: none;
        }

        #score {
            top: 20px;
            right: 20px;
            font-size: 24px;
        }

        #combo {
            top: 20px;
            right: 50%;
            transform: translateX(50%);
            font-size: 20px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #combo.active {
            opacity: 1;
        }

        #highScore {
            top: 20px;
            left: 20px;
            font-size: 18px;
        }

        /* Power-up indicators */
        .power-up-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .power-up-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            opacity: 0.5;
            transition: all 0.3s;
        }

        .power-up-icon.active {
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
        }

        /* Menus */
        .menu {
            position: absolute;
            top: 0;
            right: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s;
        }

        .menu.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .menu h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #FFD700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
            animation: pulse 2s infinite;
        }

        .menu p {
            font-size: 18px;
            margin-bottom: 30px;
            color: #FFF;
            text-align: center;
            max-width: 80%;
        }

        .menu button {
            padding: 15px 30px;
            margin: 10px;
            font-size: 20px;
            font-weight: bold;
            color: white;
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .menu button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .menu button:active {
            transform: translateY(0);
        }

        /* Controls */
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        /* Sound toggle */
        #soundToggle {
            position: absolute;
            top: 20px;
            left: 60px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 10;
        }

        #soundToggle:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Music toggle */
        #musicToggle {
            position: absolute;
            top: 20px;
            left: 110px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 10;
        }

        #musicToggle:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Animations */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }

        @keyframes fireworks {
            0% { transform: translateY(0) scale(0); opacity: 1; }
            50% { opacity: 1; }
            100% { transform: translateY(-100px) scale(1); opacity: 0; }
        }

        @keyframes throneGlow {
            0% { filter: drop-shadow(0 0 5px gold); }
            50% { filter: drop-shadow(0 0 20px gold) drop-shadow(0 0 30px orange); }
            100% { filter: drop-shadow(0 0 5px gold); }
        }

        @keyframes rainbow {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px #fff; }
            50% { box-shadow: 0 0 20px #fff, 0 0 30px #ff00ff; }
        }

        .shake {
            animation: shake 0.5s;
        }

        .rainbow-text {
            background: linear-gradient(90deg, red, orange, yellow, green, blue, indigo, violet);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: rainbow 3s infinite linear;
        }

        /* Developer credit */
        #developerCredit {
            position: absolute;
            bottom: 10px;
            right: 50%;
            transform: translateX(50%);
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        /* Win Menu */
        #winMenu {
            background: linear-gradient(135deg, rgba(106, 27, 154, 0.9) 0%, rgba(49, 27, 146, 0.9) 100%);
        }

        #winMenu h1 {
            font-size: 60px;
            color: #FFD700;
            text-shadow: 0 0 20px #FF6B00, 0 0 30px #FF4081;
            animation: pulse 1.5s infinite;
        }

        #winMenu p {
            font-size: 24px;
            color: #E1BEE7;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .throne-container {
            position: relative;
            margin: 20px 0;
        }

        .throne {
            font-size: 80px;
            animation: throneGlow 2s infinite;
            filter: drop-shadow(0 0 10px gold);
        }

        .wizard-on-throne {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            filter: drop-shadow(0 0 5px white);
        }

        .firework {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: fireworks 1.5s ease-out forwards;
        }

        /* Achievements */
        .achievement-popup {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            border-left: 5px solid gold;
            animation: slideIn 0.5s ease-out;
            z-index: 200;
            max-width: 300px;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* New Power-up Indicators */
        .new-power-up-indicator {
            animation: glow 1s infinite;
        }

        /* Tutorial hints */
        .tutorial-hint {
            position: absolute;
            bottom: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            max-width: 200px;
            animation: float 3s infinite;
        }

        /* Daily Reward */
        .daily-reward {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            z-index: 300;
            animation: pulse 2s infinite;
        }

        /* Character Customization */
        .character-customization {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }

        .color-option {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
        }

        .color-option.selected {
            border-color: white;
            transform: scale(1.2);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .menu h1 {
                font-size: 36px;
            }
            
            .menu p {
                font-size: 16px;
            }
            
            .menu button {
                padding: 12px 24px;
                font-size: 18px;
            }
            
            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }

            #winMenu h1 {
                font-size: 40px;
            }

            .throne {
                font-size: 60px;
            }

            .wizard-on-throne {
                font-size: 30px;
            }

            .power-up-indicator {
                bottom: 80px;
            }

            .controls {
                bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- UI Elements -->
        <div id="score" class="ui-element">Ø§Ù„Ù†Ù‚Ø§Ø·: 0</div>
        <div id="combo" class="ui-element">Ù…Ø¶Ø§Ø¹Ù x1</div>
        <div id="highScore" class="ui-element">Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø©: 0</div>
        
        <!-- Power-up indicators -->
        <div class="power-up-indicator">
            <div id="shieldIndicator" class="power-up-icon" title="Ø¯Ø±Ø¹">ğŸ›¡ï¸</div>
            <div id="magnetIndicator" class="power-up-icon" title="Ù…ØºÙ†Ø§Ø·ÙŠØ³">ğŸ§²</div>
            <div id="speedIndicator" class="power-up-icon" title="Ø³Ø±Ø¹Ø© ÙØ§Ø¦Ù‚Ø©">âš¡</div>
            <div id="giantIndicator" class="power-up-icon" title="Ø¹Ù…Ù„Ø§Ù‚">ğŸ¦£</div>
            <div id="freezeIndicator" class="power-up-icon" title="ØªØ¬Ù…ÙŠØ¯ Ø§Ù„ÙˆÙ‚Øª">â„ï¸</div>
            <div id="flyIndicator" class="power-up-icon" title="Ø·ÙŠØ±Ø§Ù†">ğŸ¦…</div>
            <div id="cloneIndicator" class="power-up-icon" title="Ø§Ø³ØªÙ†Ø³Ø§Ø®">ğŸ‘¥</div>
            <div id="invisIndicator" class="power-up-icon" title="ØªØ®ÙÙŠ">ğŸ‘»</div>
        </div>
        
        <!-- Sound controls -->
        <div id="soundToggle" title="ØªØ´ØºÙŠÙ„/Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØµÙˆØª">ğŸ”Š</div>
        <div id="musicToggle" title="ØªØ´ØºÙŠÙ„/Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰">ğŸµ</div>
        
        <!-- Mobile controls -->
        <div class="controls">
            <div id="jumpBtn" class="control-btn" title="Ù‚ÙØ²">â¬†ï¸</div>
            <div id="dashBtn" class="control-btn" title="Ø§Ù†Ø¯ÙØ§Ø¹">ğŸ’¨</div>
            <div id="attackBtn" class="control-btn" title="Ù‡Ø¬ÙˆÙ…" style="display: none;">ğŸ”¥</div>
            <div id="specialBtn" class="control-btn" title="Ù‚ÙˆØ© Ø®Ø§ØµØ©" style="display: none;">âœ¨</div>
        </div>
        
        <!-- Tutorial Hint -->
        <div id="tutorialHint" class="tutorial-hint hidden" style="display: none;">
            ğŸ’¡ ØªÙ„Ù…ÙŠØ­: Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø²Ø± Ø§Ù„Ù‚ÙØ² Ù…Ø±ØªÙŠÙ† Ù„Ù„Ù‚ÙØ² Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬!
        </div>
        
        <!-- Developer credit -->
        <div id="developerCredit">ØªÙ… ØªØ·ÙˆÙŠØ± Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨ÙˆØ§Ø³Ø·Ø© Ø¹Ø¨Ø¯ Ø§Ù„Ù„Ù‡ - Ø§Ù„Ø¥ØµØ¯Ø§Ø± Ø§Ù„Ù…Ø­Ø³Ù† 2.0</div>
        
        <!-- Start Menu -->
        <div id="startMenu" class="menu">
            <h1 class="rainbow-text">Ø¹Ø¯Ø§Ø¡ Ø§Ù„Ø³Ø­Ø±</h1>
            <p>Ø§Ù†Ø¶Ù… Ø¥Ù„Ù‰ Ø§Ù„Ø³Ø§Ø­Ø± ÙÙŠ Ù…ØºØ§Ù…Ø±Ø© Ø³Ø§Ø­Ø±Ø©! Ø§Ù‚ÙØ²ØŒ Ø§Ù†Ø¯ÙØ¹ØŒ ÙˆØ¬Ù…Ø¹ Ø§Ù„ÙƒØ±Ø§Øª Ø§Ù„Ø³Ø­Ø±ÙŠØ© Ù„Ù„Ø¨Ù‚Ø§Ø¡!</p>
            <button id="startBtn">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
            <button id="instructionsBtn">ÙƒÙŠÙÙŠØ© Ø§Ù„Ù„Ø¹Ø¨</button>
            <button id="customizeBtn">ØªØ®ØµÙŠØµ Ø§Ù„Ø´Ø®ØµÙŠØ©</button>
            <button id="achievementsBtn">Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²Ø§Øª</button>
        </div>
        
        <!-- Customization Menu -->
        <div id="customizationMenu" class="menu hidden">
            <h1>ØªØ®ØµÙŠØµ Ø§Ù„Ø³Ø§Ø­Ø±</h1>
            <p>Ø§Ø®ØªØ± Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ù…ÙØ¶Ù„ Ù„Ø³Ø§Ø­Ø±Ùƒ:</p>
            <div class="character-customization">
                <div class="color-option" style="background: #4a148c;" data-color="#4a148c"></div>
                <div class="color-option" style="background: #d32f2f;" data-color="#d32f2f"></div>
                <div class="color-option" style="background: #1976d2;" data-color="#1976d2"></div>
                <div class="color-option" style="background: #388e3c;" data-color="#388e3c"></div>
                <div class="color-option" style="background: #f57c00;" data-color="#f57c00"></div>
                <div class="color-option" style="background: #7b1fa2;" data-color="#7b1fa2"></div>
            </div>
            <button id="saveCustomizationBtn">Ø­ÙØ¸</button>
            <button id="backFromCustomBtn">Ø±Ø¬ÙˆØ¹</button>
        </div>
        
        <!-- Achievements Menu -->
        <div id="achievementsMenu" class="menu hidden">
            <h1>Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²Ø§Øª</h1>
            <div id="achievementsList" style="color: white; text-align: right; max-height: 300px; overflow-y: auto; padding: 20px;">
                <!-- Achievements will be added here dynamically -->
            </div>
            <button id="backFromAchievementsBtn">Ø±Ø¬ÙˆØ¹</button>
        </div>
        
        <!-- Instructions Menu -->
        <div id="instructionsMenu" class="menu hidden">
            <h1>ÙƒÙŠÙÙŠØ© Ø§Ù„Ù„Ø¹Ø¨</h1>
            <p>
                <strong>Ø§Ù„Ø­Ø§Ø³ÙˆØ¨:</strong><br>
                â€¢ Ø³Ù‡Ù… Ø§Ù„Ø£Ø¹Ù„Ù‰ Ø£Ùˆ Ø§Ù„Ù…Ø³Ø§ÙØ©: Ø§Ù„Ù‚ÙØ²<br>
                â€¢ Ø³Ù‡Ù… Ø§Ù„Ø£Ø¹Ù„Ù‰ Ù…Ø±ØªÙŠÙ†: Ø§Ù„Ù‚ÙØ² Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬<br>
                â€¢ Shift: Ø§Ù„Ø§Ù†Ø¯ÙØ§Ø¹ Ø§Ù„Ø³Ø±ÙŠØ¹<br>
                â€¢ Ctrl: Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø¹ÙŠÙ…<br>
                â€¢ Q: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù‚ÙˆØ© Ø§Ù„Ø®Ø§ØµØ©<br>
                â€¢ ESC: Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª<br><br>
                
                <strong>Ø§Ù„Ù‡Ø§ØªÙ:</strong><br>
                â€¢ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø©<br><br>
                
                <strong>Ù‡Ø¯Ù Ø§Ù„Ù„Ø¹Ø¨Ø©:</strong><br>
                â€¢ Ø§Ø¬Ù…Ø¹ Ø§Ù„ÙƒØ±Ø§Øª Ø§Ù„Ø³Ø­Ø±ÙŠØ© Ù„Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù†Ù‚Ø§Ø·<br>
                â€¢ ØªØ¬Ù†Ø¨ Ø§Ù„Ø¹Ù‚Ø¨Ø§Øª ÙˆØ§Ù„Ø£Ø¹Ø¯Ø§Ø¡<br>
                â€¢ Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‚ÙˆÙ‰ Ø§Ù„Ø®Ø§ØµØ©<br>
                â€¢ Ø§Ù‡Ø²Ù… Ø§Ù„Ø²Ø¹ÙŠÙ… Ø¹Ù†Ø¯ 500 Ù†Ù‚Ø·Ø©<br>
                â€¢ Ø§Ø³ØªÙ…ØªØ¹ Ø¨Ø§Ù„Ù…ØºØ§Ù…Ø±Ø©!
            </p>
            <button id="backBtn">Ø±Ø¬ÙˆØ¹</button>
        </div>
        
        <!-- Pause Menu -->
        <div id="pauseMenu" class="menu hidden">
            <h1>Ø§Ù„Ù„Ø¹Ø¨Ø© Ù…ØªÙˆÙ‚ÙØ©</h1>
            <p>Ø®Ø° Ù‚Ø³Ø·Ù‹Ø§ Ù…Ù† Ø§Ù„Ø±Ø§Ø­Ø©ØŒ Ø£ÙŠÙ‡Ø§ Ø§Ù„Ø³Ø§Ø­Ø± Ø§Ù„Ø´Ø¬Ø§Ø¹!</p>
            <button id="resumeBtn">Ø§Ø³ØªØ¦Ù†Ø§Ù</button>
            <button id="restartBtn">Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„</button>
            <button id="mainMenuBtn">Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
        </div>
        
        <!-- Game Over Menu -->
        <div id="gameOverMenu" class="menu hidden">
            <h1>Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©</h1>
            <p id="finalScore">Ù†Ù‚Ø§Ø·Ùƒ: 0</p>
            <p id="newAchievements" style="color: gold; font-size: 16px; margin: 10px;"></p>
            <button id="tryAgainBtn">Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰</button>
            <button id="mainMenuBtn2">Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
        </div>

        <!-- Win Menu -->
        <div id="winMenu" class="menu hidden">
            <h1>ğŸ‰ Ø§Ù†ØªØµØ±Øª! ğŸ‰</h1>
            <p>Ù„Ù‚Ø¯ Ù‡Ø²Ù…Øª Ø§Ù„Ø²Ø¹ÙŠÙ… Ø§Ù„Ø´Ø±ÙŠØ± ÙˆØ£Ø¹Ø¯Øª Ø§Ù„Ø³Ù„Ø§Ù… Ø¥Ù„Ù‰ Ø§Ù„Ù…Ù…Ù„ÙƒØ©!</p>
            <div class="throne-container">
                <div class="throne">ğŸª‘</div>
                <div class="wizard-on-throne">ğŸ§™â€â™‚ï¸</div>
            </div>
            <p id="winScore">Ù†Ù‚Ø§Ø·Ùƒ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: 0</p>
            <p id="winAchievements" style="color: gold; font-size: 18px; margin: 15px;"></p>
            <button id="winRestartBtn">Ø§Ù„Ø¹Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰</button>
            <button id="winMainMenuBtn">Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
        </div>
    </div>

    <script>
        // ==============================================
        // GAME CONFIGURATION
        // ==============================================
        const CONFIG = {
            WIDTH: 900,
            HEIGHT: 600,
            
            PLAYER: {
                WIDTH: 50,
                HEIGHT: 60,
                JUMP_FORCE: -15,
                GRAVITY: 0.6,
                DASH_FORCE: 20,
                DASH_COOLDOWN: 1000,
                DOUBLE_JUMP_FORCE: -12,
                INVINCIBLE_DURATION: 2000,
                GIANT_DURATION: 5000,
                GIANT_SCALE: 1.8,
                FLY_DURATION: 3000,
                MAGNET_RANGE: 150,
                ATTACK_COOLDOWN: 100,
                ATTACK_DAMAGE: 1,
                ATTACK_RANGE: 200,
                PROJECTILE_SPEED: 8,
                CLONE_DURATION: 5000,
                INVIS_DURATION: 4000,
                TIME_SLOW_DURATION: 3000
            },
            
            GAME: {
                INITIAL_SPEED: 5,
                SPEED_INCREMENT: 0.001,
                MAX_SPEED: 12,
                OBSTACLE_SPAWN_RATE: 0.02,
                ENEMY_SPAWN_RATE: 0.01,
                ORB_SPAWN_RATE: 0.03,
                POWERUP_SPAWN_RATE: 0.005,
                BOSS_THRESHOLD: 500,
                COMBO_TIME: 2000,
                PARTICLE_COUNT: 3,
                SHAKE_INTENSITY: 5,
                GROUND_HEIGHT: 100
            },
            
            VISUAL: {
                PARALLAX_LAYERS: 5,
                PARTICLE_LIFETIME: 60,
                TRAIL_LENGTH: 10,
                GLOW_RADIUS: 15,
                STAR_COUNT: 100
            }
        };

        // Game States
        const GameState = {
            MENU: 'menu',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'game_over',
            BOSS: 'boss',
            WIN: 'win'
        };

        // Power-up Types (Expanded)
        const PowerUpType = {
            SHIELD: 'shield',
            MAGNET: 'magnet',
            SPEED: 'speed',
            GIANT: 'giant',
            FREEZE: 'freeze',
            FLY: 'fly',
            CLONE: 'clone',
            INVISIBLE: 'invisible',
            TIME_SLOW: 'time_slow',
            RAINBOW: 'rainbow'
        };

        // Achievements
        const ACHIEVEMENTS = [
            { id: 'first_orb', name: 'Ø§Ù„Ù…Ø¨ØªØ¯Ø¦', description: 'Ø§Ø¬Ù…Ø¹ Ø£ÙˆÙ„ ÙƒØ±Ø© Ø³Ø­Ø±ÙŠØ©', earned: false, points: 10 },
            { id: 'first_jump', name: 'Ø§Ù„Ù‚Ø§ÙØ²', description: 'Ù‚Ù… Ø¨Ø£ÙˆÙ„ Ù‚ÙØ²Ø©', earned: false, points: 5 },
            { id: 'first_powerup', name: 'Ø§Ù„Ù‚ÙˆØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©', description: 'Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø£ÙˆÙ„ Ù‚ÙˆØ© Ø®Ø§ØµØ©', earned: false, points: 15 },
            { id: 'combo_master', name: 'Ø³ÙŠØ¯ Ø§Ù„ØªØ³Ù„Ø³Ù„', description: 'Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù…Ø¶Ø§Ø¹Ù x5', earned: false, points: 25 },
            { id: 'speed_demon', name: 'Ø´ÙŠØ·Ø§Ù† Ø§Ù„Ø³Ø±Ø¹Ø©', description: 'Ø§Ø³ØªØ®Ø¯Ù… Ù‚ÙˆØ© Ø§Ù„Ø³Ø±Ø¹Ø© 5 Ù…Ø±Ø§Øª', earned: false, points: 20 },
            { id: 'orb_collector', name: 'Ø¬Ø§Ù…Ø¹ Ø§Ù„ÙƒØ±Ø§Øª', description: 'Ø§Ø¬Ù…Ø¹ 50 ÙƒØ±Ø© Ø³Ø­Ø±ÙŠØ©', earned: false, points: 50 },
            { id: 'boss_slayer', name: 'Ù‚Ø§ØªÙ„ Ø§Ù„Ø²Ø¹ÙŠÙ…', description: 'Ø§Ù‡Ø²Ù… Ø§Ù„Ø²Ø¹ÙŠÙ… Ø§Ù„Ø´Ø±ÙŠØ±', earned: false, points: 100 },
            { id: 'perfect_run', name: 'Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„Ù…Ø«Ø§Ù„ÙŠØ©', description: 'Ø§Ù„Ø¹Ø¨ Ø¯ÙˆÙ† Ù„Ù…Ø³ Ø£ÙŠ Ø¹Ø§Ø¦Ù‚', earned: false, points: 75 },
            { id: 'power_master', name: 'Ø³Ø§Ø­Ø± Ø§Ù„Ù‚ÙˆÙ‰', description: 'Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ ÙƒÙ„ Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù‚ÙˆÙ‰ Ø§Ù„Ø®Ø§ØµØ©', earned: false, points: 150 },
            { id: 'high_score', name: 'Ø§Ù„Ø¨Ø·Ù„ Ø§Ù„Ø£Ø³Ø·ÙˆØ±ÙŠ', description: 'Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ 1000 Ù†Ù‚Ø·Ø©', earned: false, points: 200 }
        ];

        // ==============================================
        // MAIN GAME CLASS
        // ==============================================
        class MagicalRunner {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas();
                
                // Game state
                this.state = GameState.MENU;
                this.score = 0;
                this.highScore = parseInt(localStorage.getItem('magicalRunnerHighScore') || '0');
                this.combo = 0;
                this.comboTimer = 0;
                this.multiplier = 1;
                this.speed = CONFIG.GAME.INITIAL_SPEED;
                this.soundEnabled = true;
                this.musicEnabled = true;
                this.shakeAmount = 0;
                this.bossDefeated = false;
                this.orbsCollected = 0;
                this.powerupsUsed = 0;
                this.playerColor = localStorage.getItem('playerColor') || '#4a148c';
                this.timeSlowActive = false;
                this.timeSlowTimer = 0;
                
                // Load achievements
                this.achievements = JSON.parse(localStorage.getItem('magicalRunnerAchievements') || '[]');
                if (this.achievements.length === 0) {
                    this.achievements = ACHIEVEMENTS;
                }
                
                // Game objects
                this.player = null;
                this.obstacles = [];
                this.enemies = [];
                this.orbs = [];
                this.powerUps = [];
                this.particles = [];
                this.stars = [];
                this.boss = null;
                this.bossProjectiles = [];
                this.playerProjectiles = [];
                this.clones = [];
                this.rainbowTrails = [];
                
                // Parallax backgrounds
                this.parallaxLayers = [];
                this.groundOffset = 0;
                
                // Audio
                this.audioContext = null;
                this.music = null;
                
                // Input handling
                this.keys = {};
                this.touchStartX = 0;
                this.touchStartY = 0;
                
                // Initialize
                this.init();
            }
            
            setupCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const rect = this.canvas.getBoundingClientRect();
                
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
            }
            
            init() {
                // Initialize player
                this.player = new Player(
                    CONFIG.WIDTH * 0.2,
                    CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - CONFIG.PLAYER.HEIGHT,
                    CONFIG.PLAYER.WIDTH,
                    CONFIG.PLAYER.HEIGHT,
                    this.playerColor
                );
                
                // Initialize stars
                this.initStars();
                
                // Initialize parallax
                this.initParallaxLayers();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Update UI
                this.updateUI();
                
                // Load achievements display
                this.loadAchievementsDisplay();
                
                // Start game loop
                this.gameLoop();
            }
            
            initStars() {
                for (let i = 0; i < CONFIG.VISUAL.STAR_COUNT; i++) {
                    this.stars.push({
                        x: Math.random() * CONFIG.WIDTH,
                        y: Math.random() * (CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT),
                        size: Math.random() * 2 + 0.5,
                        speed: Math.random() * 0.5 + 0.1,
                        opacity: Math.random() * 0.8 + 0.2,
                        twinkle: Math.random() * 0.1 + 0.05
                    });
                }
            }
            
            initParallaxLayers() {
                const colors = [
                    'rgba(25, 25, 112, 0.2)',
                    'rgba(70, 130, 180, 0.3)',
                    'rgba(100, 149, 237, 0.4)',
                    'rgba(135, 206, 250, 0.5)',
                    'rgba(176, 224, 230, 0.6)'
                ];
                
                for (let i = 0; i < CONFIG.VISUAL.PARALLAX_LAYERS; i++) {
                    this.parallaxLayers.push({
                        y: (CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT) * (i / CONFIG.VISUAL.PARALLAX_LAYERS),
                        height: (CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT) / CONFIG.VISUAL.PARALLAX_LAYERS,
                        color: colors[i],
                        speed: (i + 1) * 0.2,
                        elements: []
                    });
                    
                    const elementCount = 5 + i * 2;
                    for (let j = 0; j < elementCount; j++) {
                        this.parallaxLayers[i].elements.push({
                            x: Math.random() * CONFIG.WIDTH,
                            width: Math.random() * 100 + 50,
                            height: Math.random() * 30 + 20,
                            type: Math.random() > 0.5 ? 'mountain' : 'tree'
                        });
                    }
                }
            }
            
            setupEventListeners() {
                // Keyboard events
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                    
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Control', 'Shift', 'q', 'Q', 'Escape'].includes(e.key)) {
                        e.preventDefault();
                    }
                    
                    // Jump
                    if ((e.key === ' ' || e.key === 'ArrowUp') && 
                        (this.state === GameState.PLAYING || this.state === GameState.BOSS)) {
                        this.player.jump();
                    }
                    
                    // Dash
                    if (e.key === 'Shift' && 
                        (this.state === GameState.PLAYING || this.state === GameState.BOSS)) {
                        this.player.dash();
                    }
                    
                    // Attack
                    if (e.key === 'Control' && this.state === GameState.BOSS) {
                        this.player.attack();
                    }
                    
                    // Special power
                    if ((e.key === 'q' || e.key === 'Q') && 
                        (this.state === GameState.PLAYING || this.state === GameState.BOSS)) {
                        this.player.useSpecial();
                    }
                    
                    // Pause
                    if (e.key === 'Escape' && 
                        (this.state === GameState.PLAYING || this.state === GameState.BOSS)) {
                        this.pause();
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });
                
                // Touch events for mobile
                this.canvas.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    this.touchStartX = touch.clientX;
                    this.touchStartY = touch.clientY;
                    
                    // Check if it's in the game area (not on UI buttons)
                    const rect = this.canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    if (y > rect.height - 100) return; // Don't jump if touching controls area
                    
                    if (this.state === GameState.PLAYING || this.state === GameState.BOSS) {
                        this.player.jump();
                    }
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                });
                
                // Mobile control buttons
                document.getElementById('jumpBtn').addEventListener('click', () => {
                    if (this.state === GameState.PLAYING || this.state === GameState.BOSS) {
                        this.player.jump();
                    }
                });
                
                document.getElementById('dashBtn').addEventListener('click', () => {
                    if (this.state === GameState.PLAYING || this.state === GameState.BOSS) {
                        this.player.dash();
                    }
                });
                
                document.getElementById('attackBtn').addEventListener('click', () => {
                    if (this.state === GameState.BOSS) {
                        this.player.attack();
                    }
                });
                
                document.getElementById('specialBtn').addEventListener('click', () => {
                    if (this.state === GameState.PLAYING || this.state === GameState.BOSS) {
                        this.player.useSpecial();
                    }
                });
                
                // Menu buttons
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('instructionsBtn').addEventListener('click', () => {
                    document.getElementById('startMenu').classList.add('hidden');
                    document.getElementById('instructionsMenu').classList.remove('hidden');
                });
                document.getElementById('customizeBtn').addEventListener('click', () => {
                    document.getElementById('startMenu').classList.add('hidden');
                    document.getElementById('customizationMenu').classList.remove('hidden');
                    this.setupCustomization();
                });
                document.getElementById('achievementsBtn').addEventListener('click', () => {
                    document.getElementById('startMenu').classList.add('hidden');
                    document.getElementById('achievementsMenu').classList.remove('hidden');
                    this.loadAchievementsDisplay();
                });
                document.getElementById('backBtn').addEventListener('click', () => {
                    document.getElementById('instructionsMenu').classList.add('hidden');
                    document.getElementById('startMenu').classList.remove('hidden');
                });
                document.getElementById('backFromCustomBtn').addEventListener('click', () => {
                    document.getElementById('customizationMenu').classList.add('hidden');
                    document.getElementById('startMenu').classList.remove('hidden');
                });
                document.getElementById('backFromAchievementsBtn').addEventListener('click', () => {
                    document.getElementById('achievementsMenu').classList.add('hidden');
                    document.getElementById('startMenu').classList.remove('hidden');
                });
                document.getElementById('saveCustomizationBtn').addEventListener('click', () => this.saveCustomization());
                document.getElementById('resumeBtn').addEventListener('click', () => this.resume());
                document.getElementById('restartBtn').addEventListener('click', () => this.restart());
                document.getElementById('mainMenuBtn').addEventListener('click', () => this.mainMenu());
                document.getElementById('tryAgainBtn').addEventListener('click', () => this.restart());
                document.getElementById('mainMenuBtn2').addEventListener('click', () => this.mainMenu());
                document.getElementById('winRestartBtn').addEventListener('click', () => this.restart());
                document.getElementById('winMainMenuBtn').addEventListener('click', () => this.mainMenu());
                
                // Sound controls
                document.getElementById('soundToggle').addEventListener('click', () => {
                    this.soundEnabled = !this.soundEnabled;
                    document.getElementById('soundToggle').textContent = this.soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
                });
                
                document.getElementById('musicToggle').addEventListener('click', () => {
                    this.musicEnabled = !this.musicEnabled;
                    document.getElementById('musicToggle').textContent = this.musicEnabled ? 'ğŸµ' : 'ğŸ¶';
                    if (this.musicEnabled && this.state === GameState.PLAYING) {
                        this.playBackgroundMusic();
                    } else if (this.music) {
                        this.music.stop();
                    }
                });
                
                // Color customization
                document.querySelectorAll('.color-option').forEach(option => {
                    option.addEventListener('click', (e) => {
                        document.querySelectorAll('.color-option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                        e.target.classList.add('selected');
                    });
                });
                
                // Show tutorial hint after 5 seconds
                setTimeout(() => {
                    if (this.state === GameState.PLAYING) {
                        this.showTutorialHint('ğŸ’¡ ØªÙ„Ù…ÙŠØ­: Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø²Ø± Ø§Ù„Ù‚ÙØ² Ù…Ø±ØªÙŠÙ† Ù„Ù„Ù‚ÙØ² Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬!');
                    }
                }, 5000);
            }
            
            setupCustomization() {
                const savedColor = localStorage.getItem('playerColor') || '#4a148c';
                document.querySelectorAll('.color-option').forEach(option => {
                    if (option.dataset.color === savedColor) {
                        option.classList.add('selected');
                    }
                });
            }
            
            saveCustomization() {
                const selected = document.querySelector('.color-option.selected');
                if (selected) {
                    this.playerColor = selected.dataset.color;
                    localStorage.setItem('playerColor', this.playerColor);
                    if (this.player) {
                        this.player.color = this.playerColor;
                    }
                    document.getElementById('customizationMenu').classList.add('hidden');
                    document.getElementById('startMenu').classList.remove('hidden');
                }
            }
            
            loadAchievementsDisplay() {
                const list = document.getElementById('achievementsList');
                list.innerHTML = '';
                
                this.achievements.forEach(ach => {
                    const div = document.createElement('div');
                    div.style.cssText = `
                        background: ${ach.earned ? 'rgba(0, 255, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)'};
                        border-left: 5px solid ${ach.earned ? 'gold' : 'gray'};
                        padding: 10px;
                        margin: 5px 0;
                        border-radius: 5px;
                    `;
                    div.innerHTML = `
                        <strong>${ach.name}</strong><br>
                        <small>${ach.description}</small><br>
                        <small style="color: gold;">${ach.points} Ù†Ù‚Ø·Ø©</small>
                        ${ach.earned ? '<br><small style="color: lightgreen;">âœ“ ØªÙ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„ÙŠÙ‡</small>' : ''}
                    `;
                    list.appendChild(div);
                });
            }
            
            checkAchievements() {
                const newAchievements = [];
                
                // Check each achievement
                this.achievements.forEach(ach => {
                    if (!ach.earned) {
                        let earned = false;
                        
                        switch(ach.id) {
                            case 'first_orb':
                                earned = this.orbsCollected >= 1;
                                break;
                            case 'first_jump':
                                // This would need additional tracking
                                break;
                            case 'first_powerup':
                                earned = this.powerupsUsed >= 1;
                                break;
                            case 'combo_master':
                                earned = this.multiplier >= 5;
                                break;
                            case 'speed_demon':
                                // Need additional tracking
                                break;
                            case 'orb_collector':
                                earned = this.orbsCollected >= 50;
                                break;
                            case 'boss_slayer':
                                earned = this.bossDefeated;
                                break;
                            case 'high_score':
                                earned = this.score >= 1000;
                                break;
                        }
                        
                        if (earned) {
                            ach.earned = true;
                            newAchievements.push(ach);
                            this.showAchievement(ach);
                        }
                    }
                });
                
                // Save achievements
                localStorage.setItem('magicalRunnerAchievements', JSON.stringify(this.achievements));
                
                return newAchievements;
            }
            
            showAchievement(achievement) {
                const popup = document.createElement('div');
                popup.className = 'achievement-popup';
                popup.innerHTML = `
                    <strong>ğŸ‰ Ø¥Ù†Ø¬Ø§Ø² Ø¬Ø¯ÙŠØ¯!</strong><br>
                    ${achievement.name}<br>
                    <small>${achievement.description}</small><br>
                    <small style="color: gold;">+${achievement.points} Ù†Ù‚Ø·Ø©</small>
                `;
                
                document.getElementById('gameContainer').appendChild(popup);
                
                // Remove after 3 seconds
                setTimeout(() => {
                    if (popup.parentNode) {
                        popup.parentNode.removeChild(popup);
                    }
                }, 3000);
            }
            
            showTutorialHint(message) {
                if (this.state !== GameState.PLAYING) return;
                
                const hint = document.getElementById('tutorialHint');
                hint.textContent = message;
                hint.style.display = 'block';
                
                setTimeout(() => {
                    hint.style.display = 'none';
                }, 5000);
            }
            
            start() {
                document.getElementById('startMenu').classList.add('hidden');
                this.state = GameState.PLAYING;
                this.reset();
                
                // Play background music if enabled
                if (this.musicEnabled) {
                    this.playBackgroundMusic();
                }
            }
            
            pause() {
                if (this.state === GameState.PLAYING || this.state === GameState.BOSS) {
                    this.state = GameState.PAUSED;
                    document.getElementById('pauseMenu').classList.remove('hidden');
                    
                    // Pause music
                    if (this.music) {
                        this.music.stop();
                    }
                }
            }
            
            resume() {
                if (this.state === GameState.PAUSED) {
                    this.state = this.boss ? GameState.BOSS : GameState.PLAYING;
                    document.getElementById('pauseMenu').classList.add('hidden');
                    
                    // Resume music
                    if (this.musicEnabled) {
                        this.playBackgroundMusic();
                    }
                }
            }
            
            restart() {
                document.getElementById('gameOverMenu').classList.add('hidden');
                document.getElementById('pauseMenu').classList.add('hidden');
                document.getElementById('winMenu').classList.add('hidden');
                this.state = GameState.PLAYING;
                this.reset();
                
                // Restart music
                if (this.musicEnabled) {
                    this.playBackgroundMusic();
                }
            }
            
            mainMenu() {
                document.getElementById('gameOverMenu').classList.add('hidden');
                document.getElementById('pauseMenu').classList.add('hidden');
                document.getElementById('instructionsMenu').classList.add('hidden');
                document.getElementById('customizationMenu').classList.add('hidden');
                document.getElementById('achievementsMenu').classList.add('hidden');
                document.getElementById('winMenu').classList.add('hidden');
                document.getElementById('startMenu').classList.remove('hidden');
                this.state = GameState.MENU;
                this.reset();
                
                // Stop music
                if (this.music) {
                    this.music.stop();
                }
            }
            
            reset() {
                // Reset game state
                this.score = 0;
                this.combo = 0;
                this.comboTimer = 0;
                this.multiplier = 1;
                this.speed = CONFIG.GAME.INITIAL_SPEED;
                this.shakeAmount = 0;
                this.bossDefeated = false;
                this.orbsCollected = 0;
                this.timeSlowActive = false;
                this.timeSlowTimer = 0;
                
                // Reset player
                this.player.reset(
                    CONFIG.WIDTH * 0.2,
                    CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - CONFIG.PLAYER.HEIGHT
                );
                
                // Clear game objects
                this.obstacles = [];
                this.enemies = [];
                this.orbs = [];
                this.powerUps = [];
                this.particles = [];
                this.boss = null;
                this.bossProjectiles = [];
                this.playerProjectiles = [];
                this.clones = [];
                this.rainbowTrails = [];
                
                // Hide special buttons
                document.getElementById('attackBtn').style.display = 'none';
                document.getElementById('specialBtn').style.display = 'none';
                
                // Reset background
                document.body.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                
                // Update UI
                this.updateUI();
            }
            
            gameLoop() {
                // Clear canvas
                this.ctx.clearRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
                
                // Update and render based on game state
                if (this.state === GameState.PLAYING || this.state === GameState.BOSS) {
                    this.update();
                    this.render();
                } else if (this.state === GameState.MENU || this.state === GameState.PAUSED || 
                          this.state === GameState.GAME_OVER || this.state === GameState.WIN) {
                    this.renderBackground();
                }
                
                // Continue game loop
                requestAnimationFrame(() => this.gameLoop());
            }
            
            update() {
                // Apply time slow
                const timeScale = this.timeSlowActive ? 0.5 : 1;
                
                // Update game speed
                if (this.state === GameState.PLAYING) {
                    this.speed = Math.min(
                        CONFIG.GAME.INITIAL_SPEED + this.score * CONFIG.GAME.SPEED_INCREMENT,
                        CONFIG.GAME.MAX_SPEED
                    ) * timeScale;
                }
                
                // Update time slow timer
                if (this.timeSlowActive) {
                    this.timeSlowTimer--;
                    if (this.timeSlowTimer <= 0) {
                        this.timeSlowActive = false;
                    }
                }
                
                // Update player
                this.player.update(timeScale);
                
                // Update parallax
                this.updateParallax();
                
                // Update stars
                this.updateStars();
                
                // Spawn game objects
                if (this.state === GameState.PLAYING) {
                    this.spawnObjects();
                }
                
                // Update game objects
                this.updateObstacles();
                this.updateEnemies();
                this.updateOrbs();
                this.updatePowerUps();
                this.updateClones();
                this.updateParticles();
                this.updatePlayerProjectiles();
                this.updateRainbowTrails();
                
                // Update boss
                if (this.state === GameState.BOSS) {
                    this.updateBoss();
                }
                
                // Update combo timer
                if (this.comboTimer > 0) {
                    this.comboTimer--;
                    if (this.comboTimer === 0) {
                        this.combo = 0;
                        this.multiplier = 1;
                        document.getElementById('combo').classList.remove('active');
                    }
                }
                
                // Check for boss spawn
                if (this.score >= CONFIG.GAME.BOSS_THRESHOLD && !this.boss && this.state === GameState.PLAYING && !this.bossDefeated) {
                    this.spawnBoss();
                }
                
                // Update screen shake
                if (this.shakeAmount > 0) {
                    this.shakeAmount *= 0.9;
                    if (this.shakeAmount < 0.1) {
                        this.shakeAmount = 0;
                    }
                }
                
                // Update UI
                this.updateUI();
            }
            
            updateParallax() {
                const speedMultiplier = this.timeSlowActive ? 0.5 : 1;
                
                for (const layer of this.parallaxLayers) {
                    for (const element of layer.elements) {
                        element.x -= this.speed * layer.speed * speedMultiplier;
                        
                        if (element.x + element.width < 0) {
                            element.x = CONFIG.WIDTH + Math.random() * 200;
                        }
                    }
                }
                
                this.groundOffset -= this.speed * speedMultiplier;
                if (this.groundOffset <= -50) {
                    this.groundOffset = 0;
                }
            }
            
            updateStars() {
                for (const star of this.stars) {
                    star.x -= star.speed * this.speed;
                    star.opacity += Math.sin(Date.now() * star.twinkle) * 0.1;
                    
                    if (star.x < 0) {
                        star.x = CONFIG.WIDTH;
                        star.y = Math.random() * (CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT);
                    }
                }
            }
            
            spawnObjects() {
                // Adjust spawn rates for time slow
                const spawnMultiplier = this.timeSlowActive ? 0.5 : 1;
                
                // Spawn obstacles
                if (Math.random() < CONFIG.GAME.OBSTACLE_SPAWN_RATE * spawnMultiplier) {
                    this.obstacles.push(new Obstacle(
                        CONFIG.WIDTH,
                        CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - 40,
                        40,
                        40,
                        this.speed
                    ));
                }
                
                // Spawn enemies
                if (Math.random() < CONFIG.GAME.ENEMY_SPAWN_RATE * spawnMultiplier) {
                    const y = CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - 100 - Math.random() * 200;
                    this.enemies.push(new Enemy(
                        CONFIG.WIDTH,
                        y,
                        40,
                        40,
                        this.speed
                    ));
                }
                
                // Spawn orbs
                if (Math.random() < CONFIG.GAME.ORB_SPAWN_RATE * spawnMultiplier) {
                    const y = CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - 50 - Math.random() * 250;
                    this.orbs.push(new Orb(
                        CONFIG.WIDTH,
                        y,
                        20,
                        this.speed
                    ));
                }
                
                // Spawn power-ups
                if (Math.random() < CONFIG.GAME.POWERUP_SPAWN_RATE * spawnMultiplier) {
                    const types = Object.values(PowerUpType);
                    const type = types[Math.floor(Math.random() * types.length)];
                    const y = CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - 50 - Math.random() * 250;
                    this.powerUps.push(new PowerUp(
                        CONFIG.WIDTH,
                        y,
                        30,
                        30,
                        type,
                        this.speed
                    ));
                }
            }
            
            updateObstacles() {
                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    const obstacle = this.obstacles[i];
                    obstacle.update();
                    
                    // Check collision with player
                    if (this.checkCollision(this.player, obstacle) && !this.player.invisible) {
                        if (!this.player.invincible) {
                            this.gameOver();
                        } else {
                            this.createExplosion(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
                            this.obstacles.splice(i, 1);
                            continue;
                        }
                    }
                    
                    // Check collision with clones
                    for (let j = this.clones.length - 1; j >= 0; j--) {
                        if (this.checkCollision(this.clones[j], obstacle)) {
                            this.createExplosion(this.clones[j].x + this.clones[j].width / 2, 
                                               this.clones[j].y + this.clones[j].height / 2);
                            this.clones.splice(j, 1);
                            break;
                        }
                    }
                    
                    // Remove if off screen
                    if (obstacle.x + obstacle.width < 0) {
                        this.obstacles.splice(i, 1);
                    }
                }
            }
            
            updateEnemies() {
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    enemy.update();
                    
                    // Check collision with player
                    if (this.checkCollision(this.player, enemy) && !this.player.invisible) {
                        if (!this.player.invincible) {
                            this.gameOver();
                        } else {
                            this.createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                            this.enemies.splice(i, 1);
                            continue;
                        }
                    }
                    
                    // Check collision with clones
                    for (let j = this.clones.length - 1; j >= 0; j--) {
                        if (this.checkCollision(this.clones[j], enemy)) {
                            this.createExplosion(this.clones[j].x + this.clones[j].width / 2, 
                                               this.clones[j].y + this.clones[j].height / 2);
                            this.clones.splice(j, 1);
                            break;
                        }
                    }
                    
                    // Remove if off screen
                    if (enemy.x + enemy.width < 0) {
                        this.enemies.splice(i, 1);
                    }
                }
            }
            
            updateOrbs() {
                for (let i = this.orbs.length - 1; i >= 0; i--) {
                    const orb = this.orbs[i];
                    orb.update();
                    
                    // Magnet effect
                    if (this.player.hasPowerUp(PowerUpType.MAGNET)) {
                        const dx = this.player.x + this.player.width / 2 - (orb.x + orb.width / 2);
                        const dy = this.player.y + this.player.height / 2 - (orb.y + orb.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < CONFIG.PLAYER.MAGNET_RANGE) {
                            orb.x += dx * 0.1;
                            orb.y += dy * 0.1;
                        }
                    }
                    
                    // Check collision with player
                    if (this.checkCollision(this.player, orb)) {
                        this.collectOrb();
                        this.createCollectEffect(orb.x + orb.width / 2, orb.y + orb.height / 2);
                        this.orbs.splice(i, 1);
                        continue;
                    }
                    
                    // Check collision with clones
                    for (let j = this.clones.length - 1; j >= 0; j--) {
                        if (this.checkCollision(this.clones[j], orb)) {
                            this.collectOrb();
                            this.createCollectEffect(orb.x + orb.width / 2, orb.y + orb.height / 2);
                            this.orbs.splice(i, 1);
                            break;
                        }
                    }
                    
                    // Remove if off screen
                    if (orb.x + orb.width < 0) {
                        this.orbs.splice(i, 1);
                    }
                }
            }
            
            updatePowerUps() {
                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    const powerUp = this.powerUps[i];
                    powerUp.update();
                    
                    // Check collision with player
                    if (this.checkCollision(this.player, powerUp)) {
                        this.player.activatePowerUp(powerUp.type);
                        this.createPowerUpEffect(powerUp.x + powerUp.width / 2, 
                                               powerUp.y + powerUp.height / 2, 
                                               powerUp.type);
                        this.powerupsUsed++;
                        this.powerUps.splice(i, 1);
                        continue;
                    }
                    
                    // Remove if off screen
                    if (powerUp.x + powerUp.width < 0) {
                        this.powerUps.splice(i, 1);
                    }
                }
            }
            
            updateClones() {
                for (let i = this.clones.length - 1; i >= 0; i--) {
                    const clone = this.clones[i];
                    clone.update();
                    
                    // Remove if timer expired
                    if (clone.timer <= 0) {
                        this.createExplosion(clone.x + clone.width / 2, clone.y + clone.height / 2);
                        this.clones.splice(i, 1);
                    }
                }
            }
            
            updateRainbowTrails() {
                for (let i = this.rainbowTrails.length - 1; i >= 0; i--) {
                    const trail = this.rainbowTrails[i];
                    trail.lifetime--;
                    
                    if (trail.lifetime <= 0) {
                        this.rainbowTrails.splice(i, 1);
                    }
                }
            }
            
            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.update();
                    
                    if (particle.lifetime <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            updatePlayerProjectiles() {
                for (let i = this.playerProjectiles.length - 1; i >= 0; i--) {
                    const projectile = this.playerProjectiles[i];
                    projectile.update();
                    
                    if (this.boss && this.checkCollision(projectile, this.boss)) {
                        this.boss.takeDamage(CONFIG.PLAYER.ATTACK_DAMAGE);
                        this.createHitEffect(projectile.x + projectile.width / 2, 
                                           projectile.y + projectile.height / 2);
                        this.playerProjectiles.splice(i, 1);
                        continue;
                    }
                    
                    if (projectile.x > CONFIG.WIDTH || projectile.y < 0 || projectile.y > CONFIG.HEIGHT) {
                        this.playerProjectiles.splice(i, 1);
                    }
                }
            }
            
            spawnBoss() {
                this.state = GameState.BOSS;
                this.boss = new Boss(
                    CONFIG.WIDTH,
                    CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - 200,
                    100,
                    150,
                    this.speed
                );
                
                // Show attack and special buttons
                document.getElementById('attackBtn').style.display = 'flex';
                document.getElementById('specialBtn').style.display = 'flex';
                
                // Screen shake
                this.shakeAmount = CONFIG.GAME.SHAKE_INTENSITY;
                
                // Change background
                document.body.style.background = 'linear-gradient(135deg, #8B0000 0%, #4B0082 100%)';
                
                // Show tutorial hint
                this.showTutorialHint('ğŸ’¡ Ø§Ø³ØªØ®Ø¯Ù… Ø²Ø± Ø§Ù„Ù‡Ø¬ÙˆÙ… ğŸ”¥ Ù„Ù…Ù‡Ø§Ø¬Ù…Ø© Ø§Ù„Ø²Ø¹ÙŠÙ…!');
            }
            
            updateBoss() {
                if (!this.boss) return;
                
                this.boss.update();
                
                // Check collision with player
                if (this.checkCollision(this.player, this.boss) && !this.player.invisible) {
                    if (!this.player.invincible) {
                        this.gameOver();
                    }
                }
                
                // Update boss projectiles
                for (let i = this.bossProjectiles.length - 1; i >= 0; i--) {
                    const projectile = this.bossProjectiles[i];
                    projectile.update();
                    
                    if (this.checkCollision(this.player, projectile) && !this.player.invisible) {
                        if (!this.player.invincible) {
                            this.gameOver();
                        } else {
                            this.createExplosion(projectile.x + projectile.width / 2, 
                                               projectile.y + projectile.height / 2);
                            this.bossProjectiles.splice(i, 1);
                            continue;
                        }
                    }
                    
                    if (projectile.x + projectile.width < 0 || projectile.y > CONFIG.HEIGHT) {
                        this.bossProjectiles.splice(i, 1);
                    }
                }
                
                // Spawn boss projectiles
                if (Math.random() < 0.02) {
                    this.bossProjectiles.push(new BossProjectile(
                        this.boss.x,
                        this.boss.y + this.boss.height / 2,
                        20,
                        20,
                        this.player
                    ));
                }
                
                // Check if boss is defeated
                if (this.boss.health <= 0) {
                    this.winGame();
                }
            }
            
            checkCollision(obj1, obj2) {
                return obj1.x < obj2.x + obj2.width &&
                       obj1.x + obj1.width > obj2.x &&
                       obj1.y < obj2.y + obj2.height &&
                       obj1.y + obj1.height > obj2.y;
            }
            
            collectOrb() {
                this.score += 10 * this.multiplier;
                this.orbsCollected++;
                this.combo++;
                this.comboTimer = CONFIG.GAME.COMBO_TIME;
                
                // Update multiplier
                if (this.combo > 0 && this.combo % 5 === 0) {
                    this.multiplier = Math.min(this.multiplier + 1, 5);
                    this.showTutorialHint(`ğŸ¯ Ù…Ù…ØªØ§Ø²! Ù…Ø¶Ø§Ø¹Ù Ø§Ù„Ù†Ù‚Ø§Ø· Ø£ØµØ¨Ø­ x${this.multiplier}`);
                }
                
                // Update combo display
                const comboElement = document.getElementById('combo');
                comboElement.textContent = `Ù…Ø¶Ø§Ø¹Ù x${this.multiplier}`;
                comboElement.classList.add('active');
                
                // Play sound
                this.playSound('collect');
                
                // Create particles
                for (let i = 0; i < CONFIG.GAME.PARTICLE_COUNT; i++) {
                    this.particles.push(new Particle(
                        this.player.x + this.player.width / 2,
                        this.player.y + this.player.height / 2,
                        Math.random() * 4 - 2,
                        Math.random() * -4 - 2,
                        'gold'
                    ));
                }
                
                // Check achievements
                this.checkAchievements();
            }
            
            createExplosion(x, y, count = 20) {
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count;
                    const speed = Math.random() * 5 + 2;
                    this.particles.push(new Particle(
                        x,
                        y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        'orange'
                    ));
                }
                
                this.shakeAmount = CONFIG.GAME.SHAKE_INTENSITY;
                this.playSound('explosion');
            }
            
            createCollectEffect(x, y) {
                for (let i = 0; i < CONFIG.GAME.PARTICLE_COUNT * 2; i++) {
                    const angle = (Math.PI * 2 * i) / (CONFIG.GAME.PARTICLE_COUNT * 2);
                    const speed = Math.random() * 2 + 1;
                    this.particles.push(new Particle(
                        x,
                        y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        'gold'
                    ));
                }
            }
            
            createPowerUpEffect(x, y, type) {
                const colors = {
                    [PowerUpType.SHIELD]: 'blue',
                    [PowerUpType.MAGNET]: 'purple',
                    [PowerUpType.SPEED]: 'yellow',
                    [PowerUpType.GIANT]: 'green',
                    [PowerUpType.FREEZE]: 'cyan',
                    [PowerUpType.FLY]: 'white',
                    [PowerUpType.CLONE]: 'pink',
                    [PowerUpType.INVISIBLE]: 'gray',
                    [PowerUpType.TIME_SLOW]: 'blueviolet',
                    [PowerUpType.RAINBOW]: 'rainbow'
                };
                
                const color = colors[type] || 'white';
                
                for (let i = 0; i < CONFIG.GAME.PARTICLE_COUNT * 3; i++) {
                    const angle = (Math.PI * 2 * i) / (CONFIG.GAME.PARTICLE_COUNT * 3);
                    const speed = Math.random() * 3 + 1;
                    this.particles.push(new Particle(
                        x,
                        y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        color === 'rainbow' ? 
                            ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'][i % 7] : 
                            color
                    ));
                }
                
                this.playSound('powerup');
            }
            
            createAttackEffect(x, y) {
                for (let i = 0; i < 15; i++) {
                    const angle = (Math.PI * 2 * i) / 15;
                    const speed = Math.random() * 3 + 2;
                    this.particles.push(new Particle(
                        x,
                        y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        'red'
                    ));
                }
                this.playSound('attack');
            }
            
            createHitEffect(x, y) {
                for (let i = 0; i < 20; i++) {
                    const angle = (Math.PI * 2 * i) / 20;
                    const speed = Math.random() * 4 + 3;
                    this.particles.push(new Particle(
                        x,
                        y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        'yellow'
                    ));
                }
                this.playSound('hit');
            }
            
            createRainbowTrail(x, y) {
                this.rainbowTrails.push({
                    x: x,
                    y: y,
                    lifetime: 30,
                    color: ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'][Math.floor(Math.random() * 7)]
                });
            }
            
            createFireworks() {
                for (let i = 0; i < 30; i++) {
                    setTimeout(() => {
                        const firework = document.createElement('div');
                        firework.className = 'firework';
                        firework.style.left = Math.random() * 100 + 'vw';
                        firework.style.backgroundColor = 
                            ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'][Math.floor(Math.random() * 6)];
                        firework.style.animationDelay = Math.random() * 2 + 's';
                        document.getElementById('winMenu').appendChild(firework);
                        
                        setTimeout(() => {
                            if (firework.parentNode) {
                                firework.parentNode.removeChild(firework);
                            }
                        }, 3000);
                    }, i * 100);
                }
            }
            
            gameOver() {
                this.state = GameState.GAME_OVER;
                
                // Hide buttons
                document.getElementById('attackBtn').style.display = 'none';
                document.getElementById('specialBtn').style.display = 'none';
                
                // Update high score
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('magicalRunnerHighScore', this.highScore.toString());
                }
                
                // Check achievements
                const newAchs = this.checkAchievements();
                
                // Show game over menu
                document.getElementById('finalScore').textContent = `Ù†Ù‚Ø§Ø·Ùƒ: ${this.score}`;
                if (newAchs.length > 0) {
                    document.getElementById('newAchievements').textContent = 
                        `ğŸ‰ Ø­ØµÙ„Øª Ø¹Ù„Ù‰ ${newAchs.length} Ø¥Ù†Ø¬Ø§Ø² Ø¬Ø¯ÙŠØ¯!`;
                }
                document.getElementById('gameOverMenu').classList.remove('hidden');
                
                // Play sound
                this.playSound('gameover');
                this.shakeAmount = CONFIG.GAME.SHAKE_INTENSITY;
                
                // Stop music
                if (this.music) {
                    this.music.stop();
                }
            }
            
            winGame() {
                this.state = GameState.WIN;
                this.bossDefeated = true;
                
                // Create explosion
                this.createExplosion(this.boss.x + this.boss.width / 2, 
                                   this.boss.y + this.boss.height / 2, 100);
                
                // Hide buttons
                document.getElementById('attackBtn').style.display = 'none';
                document.getElementById('specialBtn').style.display = 'none';
                
                // Update high score
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('magicalRunnerHighScore', this.highScore.toString());
                }
                
                // Check achievements
                const newAchs = this.checkAchievements();
                
                // Show win menu
                document.getElementById('winScore').textContent = `Ù†Ù‚Ø§Ø·Ùƒ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: ${this.score}`;
                if (newAchs.length > 0) {
                    document.getElementById('winAchievements').textContent = 
                        `ğŸ‰ Ø­ØµÙ„Øª Ø¹Ù„Ù‰ ${newAchs.length} Ø¥Ù†Ø¬Ø§Ø² Ø¬Ø¯ÙŠØ¯!`;
                }
                document.getElementById('winMenu').classList.remove('hidden');
                
                // Create fireworks
                this.createFireworks();
                setInterval(() => this.createFireworks(), 2000);
                
                // Play victory sound
                this.playSound('victory');
                this.shakeAmount = CONFIG.GAME.SHAKE_INTENSITY * 3;
                
                // Clear game objects
                this.boss = null;
                this.bossProjectiles = [];
                this.obstacles = [];
                this.enemies = [];
                this.orbs = [];
                this.powerUps = [];
                
                // Stop music
                if (this.music) {
                    this.music.stop();
                }
            }
            
            updateUI() {
                document.getElementById('score').textContent = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${this.score}`;
                document.getElementById('highScore').textContent = `Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø©: ${this.highScore}`;
                
                // Update power-up indicators
                document.getElementById('shieldIndicator').classList.toggle('active', this.player.hasPowerUp(PowerUpType.SHIELD));
                document.getElementById('magnetIndicator').classList.toggle('active', this.player.hasPowerUp(PowerUpType.MAGNET));
                document.getElementById('speedIndicator').classList.toggle('active', this.player.hasPowerUp(PowerUpType.SPEED));
                document.getElementById('giantIndicator').classList.toggle('active', this.player.hasPowerUp(PowerUpType.GIANT));
                document.getElementById('freezeIndicator').classList.toggle('active', this.player.hasPowerUp(PowerUpType.FREEZE));
                document.getElementById('flyIndicator').classList.toggle('active', this.player.hasPowerUp(PowerUpType.FLY));
                document.getElementById('cloneIndicator').classList.toggle('active', this.player.hasPowerUp(PowerUpType.CLONE));
                document.getElementById('invisIndicator').classList.toggle('active', this.player.hasPowerUp(PowerUpType.INVISIBLE));
            }
            
            render() {
                // Apply screen shake
                if (this.shakeAmount > 0) {
                    const shakeX = (Math.random() - 0.5) * this.shakeAmount;
                    const shakeY = (Math.random() - 0.5) * this.shakeAmount;
                    this.ctx.save();
                    this.ctx.translate(shakeX, shakeY);
                }
                
                // Render everything
                this.renderBackground();
                this.renderStars();
                this.renderParallax();
                this.renderGround();
                this.renderOrbs();
                this.renderPowerUps();
                this.renderObstacles();
                this.renderEnemies();
                this.renderClones();
                this.renderBoss();
                this.renderBossProjectiles();
                this.renderPlayerProjectiles();
                this.renderRainbowTrails();
                this.renderPlayer();
                this.renderParticles();
                
                // Reset transform
                if (this.shakeAmount > 0) {
                    this.ctx.restore();
                }
            }
            
            renderBackground() {
                const gradient = this.ctx.createLinearGradient(0, 0, 0, CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT);
                gradient.addColorStop(0, '#0a0e27');
                gradient.addColorStop(1, '#2a3990');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT);
            }
            
            renderStars() {
                this.ctx.fillStyle = 'white';
                for (const star of this.stars) {
                    this.ctx.globalAlpha = star.opacity;
                    this.ctx.beginPath();
                    this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.globalAlpha = 1;
            }
            
            renderParallax() {
                for (const layer of this.parallaxLayers) {
                    this.ctx.fillStyle = layer.color;
                    
                    for (const element of layer.elements) {
                        if (element.type === 'mountain') {
                            this.ctx.beginPath();
                            this.ctx.moveTo(element.x, layer.y + layer.height);
                            this.ctx.lineTo(element.x + element.width / 2, layer.y);
                            this.ctx.lineTo(element.x + element.width, layer.y + layer.height);
                            this.ctx.closePath();
                            this.ctx.fill();
                        } else {
                            this.ctx.fillRect(element.x + element.width * 0.4, layer.y + layer.height * 0.5, 
                                            element.width * 0.2, layer.height * 0.5);
                            this.ctx.beginPath();
                            this.ctx.moveTo(element.x, layer.y + layer.height * 0.5);
                            this.ctx.lineTo(element.x + element.width / 2, layer.y);
                            this.ctx.lineTo(element.x + element.width, layer.y + layer.height * 0.5);
                            this.ctx.closePath();
                            this.ctx.fill();
                        }
                    }
                }
            }
            
            renderGround() {
                // Ground
                this.ctx.fillStyle = '#3a3a3a';
                this.ctx.fillRect(0, CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT, CONFIG.WIDTH, CONFIG.GAME.GROUND_HEIGHT);
                
                // Ground pattern
                this.ctx.strokeStyle = '#2a2a2a';
                this.ctx.lineWidth = 2;
                for (let i = this.groundOffset; i < CONFIG.WIDTH; i += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT);
                    this.ctx.lineTo(i, CONFIG.HEIGHT);
                    this.ctx.stroke();
                }
            }
            
            renderPlayer() {
                if (this.player.invisible) return;
                
                this.ctx.save();
                this.ctx.translate(this.player.x + this.player.width / 2, this.player.y + this.player.height / 2);
                
                // Apply giant scale
                if (this.player.hasPowerUp(PowerUpType.GIANT)) {
                    this.ctx.scale(CONFIG.PLAYER.GIANT_SCALE, CONFIG.PLAYER.GIANT_SCALE);
                }
                
                // Apply rotation if dashing
                if (this.player.dashing) {
                    this.ctx.rotate(Math.PI / 4);
                }
                
                // Draw wizard with custom color
                this.ctx.fillStyle = this.player.color;
                this.ctx.fillRect(-this.player.width / 2, -this.player.height / 2, 
                                this.player.width, this.player.height * 0.7);
                
                // Hat
                this.ctx.fillStyle = this.shadeColor(this.player.color, -30);
                this.ctx.beginPath();
                this.ctx.moveTo(-this.player.width / 2, -this.player.height / 2);
                this.ctx.lineTo(0, -this.player.height);
                this.ctx.lineTo(this.player.width / 2, -this.player.height / 2);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Face
                this.ctx.fillStyle = '#ffdbac';
                this.ctx.fillRect(-this.player.width / 3, -this.player.height / 3, 
                                this.player.width * 2/3, this.player.height / 4);
                
                // Eyes
                this.ctx.fillStyle = 'white';
                this.ctx.fillRect(-this.player.width / 3, -this.player.height / 3, 
                                this.player.width / 6, this.player.height / 12);
                this.ctx.fillRect(this.player.width / 6, -this.player.height / 3, 
                                this.player.width / 6, this.player.height / 12);
                
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(-this.player.width / 3, -this.player.height / 3, 
                                this.player.width / 12, this.player.height / 12);
                this.ctx.fillRect(this.player.width / 4, -this.player.height / 3, 
                                this.player.width / 12, this.player.height / 12);
                
                // Beard
                this.ctx.fillStyle = 'white';
                this.ctx.fillRect(-this.player.width / 4, -this.player.height / 6, 
                                this.player.width / 2, this.player.height / 6);
                
                // Wand
                this.ctx.strokeStyle = '#8d6e63';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.width / 2, -this.player.height / 4);
                this.ctx.lineTo(this.player.width, -this.player.height / 2);
                this.ctx.stroke();
                
                // Wand star
                this.ctx.fillStyle = '#ffd700';
                this.ctx.beginPath();
                this.ctx.arc(this.player.width, -this.player.height / 2, 5, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Shield effect
                if (this.player.hasPowerUp(PowerUpType.SHIELD)) {
                    this.ctx.strokeStyle = 'rgba(0, 150, 255, 0.5)';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, this.player.width, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                // Magnet field
                if (this.player.hasPowerUp(PowerUpType.MAGNET)) {
                    this.ctx.strokeStyle = 'rgba(150, 0, 255, 0.3)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, CONFIG.PLAYER.MAGNET_RANGE, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
                
                // Rainbow trail if rainbow power-up
                if (this.player.hasPowerUp(PowerUpType.RAINBOW)) {
                    this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                    this.ctx.lineWidth = 3;
                    this.ctx.setLineDash([3, 3]);
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, this.player.width * 1.5, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
                
                // Trail if dashing
                if (this.player.dashing) {
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    for (let i = 0; i < CONFIG.VISUAL.TRAIL_LENGTH; i++) {
                        const alpha = 0.5 - (i / CONFIG.VISUAL.TRAIL_LENGTH) * 0.5;
                        this.ctx.globalAlpha = alpha;
                        this.ctx.fillRect(-this.player.width / 2 - i * 5, -this.player.height / 2, 
                                        this.player.width, this.player.height * 0.7);
                    }
                    this.ctx.globalAlpha = 1;
                }
                
                this.ctx.restore();
            }
            
            renderClones() {
                for (const clone of this.clones) {
                    this.ctx.save();
                    this.ctx.translate(clone.x + clone.width / 2, clone.y + clone.height / 2);
                    
                    this.ctx.globalAlpha = 0.7;
                    this.ctx.fillStyle = this.player.color;
                    this.ctx.fillRect(-clone.width / 2, -clone.height / 2, clone.width, clone.height * 0.7);
                    
                    this.ctx.globalAlpha = 1;
                    this.ctx.restore();
                }
            }
            
            renderRainbowTrails() {
                for (const trail of this.rainbowTrails) {
                    this.ctx.globalAlpha = trail.lifetime / 30;
                    this.ctx.fillStyle = trail.color;
                    this.ctx.beginPath();
                    this.ctx.arc(trail.x, trail.y, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.globalAlpha = 1;
            }
            
            renderPlayerProjectiles() {
                for (const projectile of this.playerProjectiles) {
                    this.ctx.fillStyle = '#ffff00';
                    this.ctx.beginPath();
                    this.ctx.arc(projectile.x + projectile.width / 2, 
                               projectile.y + projectile.height / 2, 
                               projectile.width / 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    const gradient = this.ctx.createRadialGradient(
                        projectile.x + projectile.width / 2,
                        projectile.y + projectile.height / 2,
                        0,
                        projectile.x + projectile.width / 2,
                        projectile.y + projectile.height / 2,
                        projectile.width
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(projectile.x + projectile.width / 2, 
                               projectile.y + projectile.height / 2, 
                               projectile.width, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            renderObstacles() {
                for (const obstacle of this.obstacles) {
                    this.ctx.fillStyle = '#795548';
                    this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    
                    this.ctx.fillStyle = '#4e342e';
                    this.ctx.beginPath();
                    this.ctx.moveTo(obstacle.x, obstacle.y);
                    this.ctx.lineTo(obstacle.x + obstacle.width / 2, obstacle.y - 10);
                    this.ctx.lineTo(obstacle.x + obstacle.width, obstacle.y);
                    this.ctx.closePath();
                    this.ctx.fill();
                }
            }
            
            renderEnemies() {
                for (const enemy of this.enemies) {
                    this.ctx.save();
                    this.ctx.translate(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                    
                    this.ctx.fillStyle = '#d32f2f';
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, enemy.width / 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = 'white';
                    this.ctx.beginPath();
                    this.ctx.arc(-enemy.width / 4, -enemy.height / 4, enemy.width / 8, 0, Math.PI * 2);
                    this.ctx.arc(enemy.width / 4, -enemy.height / 4, enemy.width / 8, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = 'black';
                    this.ctx.beginPath();
                    this.ctx.arc(-enemy.width / 4, -enemy.height / 4, enemy.width / 16, 0, Math.PI * 2);
                    this.ctx.arc(enemy.width / 4, -enemy.height / 4, enemy.width / 16, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    const wingFlap = Math.sin(Date.now() * 0.01) * 10;
                    this.ctx.fillStyle = 'rgba(211, 47, 47, 0.7)';
                    this.ctx.beginPath();
                    this.ctx.moveTo(-enemy.width / 2, 0);
                    this.ctx.lineTo(-enemy.width, -wingFlap);
                    this.ctx.lineTo(-enemy.width / 2, enemy.height / 2);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(enemy.width / 2, 0);
                    this.ctx.lineTo(enemy.width, -wingFlap);
                    this.ctx.lineTo(enemy.width / 2, enemy.height / 2);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            renderOrbs() {
                for (const orb of this.orbs) {
                    this.ctx.save();
                    this.ctx.translate(orb.x + orb.width / 2, orb.y + orb.height / 2);
                    this.ctx.rotate(Date.now() * 0.005);
                    
                    const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, orb.width);
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 1)');
                    gradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.5)');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, orb.width, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = '#ffd700';
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, orb.width / 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = '#fff';
                    this.ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
                        const x = Math.cos(angle) * orb.width / 4;
                        const y = Math.sin(angle) * orb.width / 4;
                        
                        if (i === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                        
                        const innerAngle = angle + Math.PI / 5;
                        const innerX = Math.cos(innerAngle) * orb.width / 8;
                        const innerY = Math.sin(innerAngle) * orb.width / 8;
                        this.ctx.lineTo(innerX, innerY);
                    }
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            renderPowerUps() {
                for (const powerUp of this.powerUps) {
                    this.ctx.save();
                    this.ctx.translate(powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2);
                    this.ctx.rotate(Date.now() * 0.003);
                    
                    const colors = {
                        [PowerUpType.SHIELD]: 'rgba(0, 150, 255, 0.5)',
                        [PowerUpType.MAGNET]: 'rgba(150, 0, 255, 0.5)',
                        [PowerUpType.SPEED]: 'rgba(255, 200, 0, 0.5)',
                        [PowerUpType.GIANT]: 'rgba(0, 200, 0, 0.5)',
                        [PowerUpType.FREEZE]: 'rgba(0, 200, 255, 0.5)',
                        [PowerUpType.FLY]: 'rgba(255, 255, 255, 0.5)',
                        [PowerUpType.CLONE]: 'rgba(255, 105, 180, 0.5)',
                        [PowerUpType.INVISIBLE]: 'rgba(128, 128, 128, 0.5)',
                        [PowerUpType.TIME_SLOW]: 'rgba(138, 43, 226, 0.5)',
                        [PowerUpType.RAINBOW]: 'rgba(255, 0, 0, 0.5)'
                    };
                    
                    const color = colors[powerUp.type] || 'rgba(255, 255, 255, 0.5)';
                    
                    const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, powerUp.width);
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, powerUp.width, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.font = `${powerUp.width}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    const icons = {
                        [PowerUpType.SHIELD]: 'ğŸ›¡ï¸',
                        [PowerUpType.MAGNET]: 'ğŸ§²',
                        [PowerUpType.SPEED]: 'âš¡',
                        [PowerUpType.GIANT]: 'ğŸ¦£',
                        [PowerUpType.FREEZE]: 'â„ï¸',
                        [PowerUpType.FLY]: 'ğŸ¦…',
                        [PowerUpType.CLONE]: 'ğŸ‘¥',
                        [PowerUpType.INVISIBLE]: 'ğŸ‘»',
                        [PowerUpType.TIME_SLOW]: 'â°',
                        [PowerUpType.RAINBOW]: 'ğŸŒˆ'
                    };
                    
                    this.ctx.fillText(icons[powerUp.type] || '?', 0, 0);
                    this.ctx.restore();
                }
            }
            
            renderBoss() {
                if (!this.boss) return;
                
                this.ctx.save();
                this.ctx.translate(this.boss.x + this.boss.width / 2, this.boss.y + this.boss.height / 2);
                
                this.ctx.fillStyle = '#8b0000';
                this.ctx.fillRect(-this.boss.width / 2, -this.boss.height / 2, 
                                this.boss.width, this.boss.height * 0.7);
                
                this.ctx.fillStyle = '#a52a2a';
                this.ctx.beginPath();
                this.ctx.arc(0, -this.boss.height / 2, this.boss.width / 2, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.fillStyle = 'red';
                this.ctx.beginPath();
                this.ctx.arc(-this.boss.width / 4, -this.boss.height / 2, this.boss.width / 8, 0, Math.PI * 2);
                this.ctx.arc(this.boss.width / 4, -this.boss.height / 2, this.boss.width / 8, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.fillStyle = '#4b0082';
                this.ctx.beginPath();
                this.ctx.moveTo(-this.boss.width / 2, -this.boss.height / 2);
                this.ctx.lineTo(-this.boss.width / 2 - 20, -this.boss.height);
                this.ctx.lineTo(-this.boss.width / 3, -this.boss.height / 2);
                this.ctx.closePath();
                this.ctx.fill();
                
                this.ctx.beginPath();
                this.ctx.moveTo(this.boss.width / 2, -this.boss.height / 2);
                this.ctx.lineTo(this.boss.width / 2 + 20, -this.boss.height);
                this.ctx.lineTo(this.boss.width / 3, -this.boss.height / 2);
                this.ctx.closePath();
                this.ctx.fill();
                
                const armSwing = Math.sin(Date.now() * 0.005) * 20;
                this.ctx.save();
                this.ctx.rotate(armSwing * Math.PI / 180);
                this.ctx.fillRect(-this.boss.width / 2 - 20, -this.boss.height / 4, 20, this.boss.height / 2);
                this.ctx.restore();
                
                this.ctx.save();
                this.ctx.rotate(-armSwing * Math.PI / 180);
                this.ctx.fillRect(this.boss.width / 2, -this.boss.height / 4, 20, this.boss.height / 2);
                this.ctx.restore();
                
                // Health bar
                this.ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                this.ctx.fillRect(-this.boss.width / 2, -this.boss.height - 30, this.boss.width, 10);
                
                this.ctx.fillStyle = 'red';
                this.ctx.fillRect(-this.boss.width / 2, -this.boss.height - 30, 
                                this.boss.width * (this.boss.health / this.boss.maxHealth), 10);
                
                this.ctx.restore();
            }
            
            renderBossProjectiles() {
                for (const projectile of this.bossProjectiles) {
                    this.ctx.fillStyle = '#ff4500';
                    this.ctx.beginPath();
                    this.ctx.arc(projectile.x + projectile.width / 2, 
                               projectile.y + projectile.height / 2, 
                               projectile.width / 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    const gradient = this.ctx.createRadialGradient(
                        projectile.x + projectile.width / 2,
                        projectile.y + projectile.height / 2,
                        0,
                        projectile.x + projectile.width / 2,
                        projectile.y + projectile.height / 2,
                        projectile.width
                    );
                    gradient.addColorStop(0, 'rgba(255, 69, 0, 0.5)');
                    gradient.addColorStop(1, 'rgba(255, 69, 0, 0)');
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(projectile.x + projectile.width / 2, 
                               projectile.y + projectile.height / 2, 
                               projectile.width, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            renderParticles() {
                for (const particle of this.particles) {
                    this.ctx.fillStyle = particle.color;
                    this.ctx.globalAlpha = particle.lifetime / CONFIG.VISUAL.PARTICLE_LIFETIME;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.globalAlpha = 1;
            }
            
            shadeColor(color, percent) {
                let R = parseInt(color.substring(1, 3), 16);
                let G = parseInt(color.substring(3, 5), 16);
                let B = parseInt(color.substring(5, 7), 16);

                R = parseInt(R * (100 + percent) / 100);
                G = parseInt(G * (100 + percent) / 100);
                B = parseInt(B * (100 + percent) / 100);

                R = (R < 255) ? R : 255;
                G = (G < 255) ? G : 255;
                B = (B < 255) ? B : 255;

                const RR = ((R.toString(16).length == 1) ? "0" + R.toString(16) : R.toString(16));
                const GG = ((G.toString(16).length == 1) ? "0" + G.toString(16) : G.toString(16));
                const BB = ((B.toString(16).length == 1) ? "0" + B.toString(16) : B.toString(16));

                return "#" + RR + GG + BB;
            }
            
            playSound(type) {
                if (!this.soundEnabled) return;
                
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                switch (type) {
                    case 'jump':
                        oscillator.frequency.value = 400;
                        oscillator.type = 'sine';
                        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.2);
                        break;
                        
                    case 'collect':
                        oscillator.frequency.value = 800;
                        oscillator.type = 'sine';
                        gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.1);
                        break;
                        
                    case 'powerup':
                        oscillator.frequency.value = 600;
                        oscillator.type = 'square';
                        gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.3);
                        break;
                        
                    case 'explosion':
                        oscillator.frequency.value = 100;
                        oscillator.type = 'sawtooth';
                        gainNode.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.3);
                        break;
                        
                    case 'gameover':
                        oscillator.frequency.value = 200;
                        oscillator.type = 'sine';
                        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.5);
                        break;
                        
                    case 'attack':
                        oscillator.frequency.value = 300;
                        oscillator.type = 'sawtooth';
                        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.2);
                        break;

                    case 'hit':
                        oscillator.frequency.value = 150;
                        oscillator.type = 'square';
                        gainNode.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.1);
                        break;

                    case 'victory':
                        const frequencies = [523, 659, 784, 1047];
                        let startTime = this.audioContext.currentTime;
                        
                        frequencies.forEach((freq, index) => {
                            const osc = this.audioContext.createOscillator();
                            const gain = this.audioContext.createGain();
                            osc.connect(gain);
                            gain.connect(this.audioContext.destination);
                            
                            osc.frequency.value = freq;
                            osc.type = 'sine';
                            gain.gain.setValueAtTime(0.3, startTime + index * 0.2);
                            gain.gain.exponentialRampToValueAtTime(0.01, startTime + index * 0.2 + 0.5);
                            
                            osc.start(startTime + index * 0.2);
                            osc.stop(startTime + index * 0.2 + 0.5);
                        });
                        break;
                }
            }
            
            playBackgroundMusic() {
                if (!this.musicEnabled || this.music) return;
                
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Create a simple background melody
                const notes = [262, 294, 330, 349, 392, 440, 494, 523];
                let currentNote = 0;
                
                const playNote = () => {
                    if (!this.musicEnabled || this.state !== GameState.PLAYING) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.value = notes[currentNote];
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.05, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.5);
                    
                    currentNote = (currentNote + 1) % notes.length;
                    
                    setTimeout(playNote, 500);
                };
                
                playNote();
            }
        }

        // ==============================================
        // GAME OBJECT CLASSES
        // ==============================================

        class Player {
            constructor(x, y, width, height, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.velocityY = 0;
                this.velocityX = 0;
                this.jumping = false;
                this.doubleJump = false;
                this.dashing = false;
                this.dashCooldown = 0;
                this.invincible = false;
                this.invincibleTimer = 0;
                this.powerUps = {};
                this.flying = false;
                this.flyTimer = 0;
                this.invisible = false;
                this.invisibleTimer = 0;
                this.attacking = false;
                this.attackCooldown = 0;
                this.attackTimer = 0;
                this.specialCooldown = 0;
                this.trail = [];
            }
            
            update(timeScale = 1) {
                // Apply gravity if not flying
                if (!this.flying) {
                    this.velocityY += CONFIG.PLAYER.GRAVITY * timeScale;
                } else {
                    // Flying mode
                    this.velocityY *= 0.9;
                    if (game.keys[' '] || game.keys['ArrowUp']) {
                        this.velocityY = -5 * timeScale;
                    } else {
                        this.velocityY += 0.2 * timeScale;
                    }
                }
                
                // Update position
                this.y += this.velocityY;
                this.x += this.velocityX * timeScale;
                
                // Ground collision
                if (!this.flying && this.y > CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - this.height) {
                    this.y = CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - this.height;
                    this.velocityY = 0;
                    this.jumping = false;
                    this.doubleJump = false;
                }
                
                // Keep player on screen
                if (this.x < 0) this.x = 0;
                if (this.x > CONFIG.WIDTH - this.width) this.x = CONFIG.WIDTH - this.width;
                
                // Update dash
                if (this.dashing) {
                    this.velocityX *= 0.9;
                    if (Math.abs(this.velocityX) < 1) {
                        this.dashing = false;
                        this.velocityX = 0;
                    }
                }
                
                // Update cooldowns
                if (this.dashCooldown > 0) this.dashCooldown--;
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.specialCooldown > 0) this.specialCooldown--;
                
                // Update attack
                if (this.attacking) {
                    this.attackTimer--;
                    if (this.attackTimer <= 0) {
                        this.attacking = false;
                    }
                }
                
                // Update invincibility
                if (this.invincibleTimer > 0) {
                    this.invincibleTimer--;
                    if (this.invincibleTimer === 0) {
                        this.invincible = false;
                    }
                }
                
                // Update invisible
                if (this.invisibleTimer > 0) {
                    this.invisibleTimer--;
                    if (this.invisibleTimer === 0) {
                        this.invisible = false;
                    }
                }
                
                // Update fly timer
                if (this.flyTimer > 0) {
                    this.flyTimer--;
                    if (this.flyTimer === 0) {
                        this.flying = false;
                    }
                }
                
                // Update power-ups
                for (const type in this.powerUps) {
                    if (this.powerUps[type] > 0) {
                        this.powerUps[type]--;
                        if (this.powerUps[type] === 0) {
                            // Deactivate power-up
                            switch (type) {
                                case PowerUpType.FLY:
                                    this.flying = false;
                                    this.velocityY = -3;
                                    break;
                                case PowerUpType.INVISIBLE:
                                    this.invisible = false;
                                    break;
                                case PowerUpType.RAINBOW:
                                    // Create rainbow explosion
                                    for (let i = 0; i < 20; i++) {
                                        const angle = (Math.PI * 2 * i) / 20;
                                        const speed = Math.random() * 3 + 2;
                                        game.particles.push(new Particle(
                                            this.x + this.width / 2,
                                            this.y + this.height / 2,
                                            Math.cos(angle) * speed,
                                            Math.sin(angle) * speed,
                                            ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'][i % 7]
                                        ));
                                    }
                                    break;
                            }
                        }
                    }
                }
                
                // Update trail
                if (this.dashing || this.hasPowerUp(PowerUpType.RAINBOW)) {
                    this.trail.push({ x: this.x, y: this.y });
                    if (this.trail.length > CONFIG.VISUAL.TRAIL_LENGTH) {
                        this.trail.shift();
                    }
                    
                    // Create rainbow trails
                    if (this.hasPowerUp(PowerUpType.RAINBOW) && Math.random() < 0.3) {
                        game.createRainbowTrail(this.x + this.width / 2, this.y + this.height / 2);
                    }
                } else {
                    this.trail = [];
                }
            }
            
            jump() {
                if (!this.jumping) {
                    this.velocityY = CONFIG.PLAYER.JUMP_FORCE;
                    this.jumping = true;
                    game.playSound('jump');
                    
                    // Check achievement
                    game.checkAchievements();
                } else if (!this.doubleJump && !this.flying) {
                    this.velocityY = CONFIG.PLAYER.DOUBLE_JUMP_FORCE;
                    this.doubleJump = true;
                    game.playSound('jump');
                }
            }
            
            dash() {
                if (this.dashCooldown === 0 && !this.dashing) {
                    this.dashing = true;
                    this.velocityX = CONFIG.PLAYER.DASH_FORCE;
                    this.dashCooldown = CONFIG.PLAYER.DASH_COOLDOWN;
                    game.playSound('jump');
                }
            }
            
            attack() {
                if (this.attackCooldown === 0 && !this.attacking) {
                    this.attacking = true;
                    this.attackTimer = 10;
                    this.attackCooldown = CONFIG.PLAYER.ATTACK_COOLDOWN;
                    game.playSound('attack');
                    
                    game.createAttackEffect(this.x + this.width, this.y + this.height / 2);
                    
                    game.playerProjectiles.push(new PlayerProjectile(
                        this.x + this.width,
                        this.y + this.height / 2 - 10,
                        15,
                        15,
                        CONFIG.PLAYER.PROJECTILE_SPEED
                    ));
                }
            }
            
            useSpecial() {
                if (this.specialCooldown === 0) {
                    // Check which special power to use
                    if (this.hasPowerUp(PowerUpType.CLONE)) {
                        this.createClone();
                    } else if (this.hasPowerUp(PowerUpType.TIME_SLOW)) {
                        this.activateTimeSlow();
                    } else if (this.hasPowerUp(PowerUpType.RAINBOW)) {
                        this.activateRainbow();
                    }
                    this.specialCooldown = 60; // 1 second cooldown
                }
            }
            
            createClone() {
                game.clones.push(new Clone(
                    this.x - 50,
                    this.y,
                    this.width,
                    this.height,
                    game.speed
                ));
                
                game.createPowerUpEffect(this.x + this.width / 2, this.y + this.height / 2, PowerUpType.CLONE);
            }
            
            activateTimeSlow() {
                game.timeSlowActive = true;
                game.timeSlowTimer = CONFIG.PLAYER.TIME_SLOW_DURATION;
                
                game.createPowerUpEffect(this.x + this.width / 2, this.y + this.height / 2, PowerUpType.TIME_SLOW);
            }
            
            activateRainbow() {
                // Create rainbow explosion
                for (let i = 0; i < 50; i++) {
                    const angle = (Math.PI * 2 * i) / 50;
                    const speed = Math.random() * 5 + 2;
                    game.particles.push(new Particle(
                        this.x + this.width / 2,
                        this.y + this.height / 2,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'][i % 7]
                    ));
                }
            }
            
            activatePowerUp(type) {
                const durations = {
                    [PowerUpType.SHIELD]: CONFIG.PLAYER.INVINCIBLE_DURATION,
                    [PowerUpType.MAGNET]: CONFIG.PLAYER.INVINCIBLE_DURATION * 2,
                    [PowerUpType.SPEED]: CONFIG.PLAYER.INVINCIBLE_DURATION,
                    [PowerUpType.GIANT]: CONFIG.PLAYER.GIANT_DURATION,
                    [PowerUpType.FREEZE]: CONFIG.PLAYER.INVINCIBLE_DURATION,
                    [PowerUpType.FLY]: CONFIG.PLAYER.FLY_DURATION,
                    [PowerUpType.CLONE]: CONFIG.PLAYER.CLONE_DURATION,
                    [PowerUpType.INVISIBLE]: CONFIG.PLAYER.INVIS_DURATION,
                    [PowerUpType.TIME_SLOW]: CONFIG.PLAYER.TIME_SLOW_DURATION,
                    [PowerUpType.RAINBOW]: CONFIG.PLAYER.INVINCIBLE_DURATION
                };
                
                this.powerUps[type] = durations[type] || CONFIG.PLAYER.INVINCIBLE_DURATION;
                
                // Apply immediate effects
                switch (type) {
                    case PowerUpType.SHIELD:
                        this.invincible = true;
                        this.invincibleTimer = Number.MAX_SAFE_INTEGER;
                        break;
                    case PowerUpType.FLY:
                        this.flying = true;
                        this.flyTimer = durations[type];
                        break;
                    case PowerUpType.INVISIBLE:
                        this.invisible = true;
                        this.invisibleTimer = durations[type];
                        break;
                }
                
                // Update game statistics
                game.powerupsUsed++;
            }
            
            hasPowerUp(type) {
                return this.powerUps[type] > 0;
            }
            
            reset(x, y) {
                this.x = x;
                this.y = y;
                this.velocityY = 0;
                this.velocityX = 0;
                this.jumping = false;
                this.doubleJump = false;
                this.dashing = false;
                this.dashCooldown = 0;
                this.invincible = false;
                this.invincibleTimer = 0;
                this.powerUps = {};
                this.flying = false;
                this.flyTimer = 0;
                this.invisible = false;
                this.invisibleTimer = 0;
                this.attacking = false;
                this.attackCooldown = 0;
                this.attackTimer = 0;
                this.specialCooldown = 0;
                this.trail = [];
            }
        }

        class Clone {
            constructor(x, y, width, height, speed) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed;
                this.timer = CONFIG.PLAYER.CLONE_DURATION;
                this.velocityY = 0;
            }
            
            update() {
                this.x -= this.speed;
                this.velocityY += CONFIG.PLAYER.GRAVITY;
                this.y += this.velocityY;
                
                // Ground collision
                if (this.y > CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - this.height) {
                    this.y = CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - this.height;
                    this.velocityY = 0;
                }
                
                this.timer--;
            }
        }

        class PlayerProjectile {
            constructor(x, y, width, height, speed) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed;
            }
            
            update() {
                this.x += this.speed;
            }
        }

        class Obstacle {
            constructor(x, y, width, height, speed) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed;
            }
            
            update() {
                this.x -= this.speed;
            }
        }

        class Enemy {
            constructor(x, y, width, height, speed) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed;
                this.amplitude = 50;
                this.frequency = 0.05;
                this.phase = Math.random() * Math.PI * 2;
                this.baseY = y;
            }
            
            update() {
                this.x -= this.speed;
                this.y = this.baseY + Math.sin(Date.now() * this.frequency + this.phase) * this.amplitude;
            }
        }

        class Orb {
            constructor(x, y, radius, speed) {
                this.x = x;
                this.y = y;
                this.width = radius;
                this.height = radius;
                this.speed = speed;
                this.rotation = 0;
                this.floatOffset = Math.random() * Math.PI * 2;
            }
            
            update() {
                this.x -= this.speed;
                this.rotation += 0.05;
                this.y += Math.sin(Date.now() * 0.005 + this.floatOffset) * 0.5;
            }
        }

        class PowerUp {
            constructor(x, y, width, height, type, speed) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.speed = speed;
                this.rotation = 0;
                this.floatOffset = Math.random() * Math.PI * 2;
            }
            
            update() {
                this.x -= this.speed;
                this.rotation += 0.03;
                this.y += Math.sin(Date.now() * 0.005 + this.floatOffset) * 0.5;
            }
        }

        class Boss {
            constructor(x, y, width, height, speed) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed;
                this.health = 10;
                this.maxHealth = 10;
                this.attackCooldown = 4;
                this.movePattern = 0;
                this.moveTimer = 0;
            }
            
            update() {
                this.moveTimer++;
                
                if (this.moveTimer > 100) {
                    this.moveTimer = 0;
                    this.movePattern = (this.movePattern + 1) % 3;
                }
                
                switch (this.movePattern) {
                    case 0:
                        this.x += Math.sin(Date.now() * 0.002) * 2;
                        break;
                    case 1:
                        this.y += Math.sin(Date.now() * 0.003) * 3;
                        break;
                    case 2:
                        this.x += Math.cos(Date.now() * 0.002) * 2;
                        this.y += Math.sin(Date.now() * 0.002) * 2;
                        break;
                }
                
                // Keep boss on screen
                if (this.x < CONFIG.WIDTH - this.width * 2) {
                    this.x = CONFIG.WIDTH - this.width * 2;
                }
                if (this.x > CONFIG.WIDTH - this.width) {
                    this.x = CONFIG.WIDTH - this.width;
                }
                if (this.y < 50) {
                    this.y = 50;
                }
                if (this.y > CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - this.height) {
                    this.y = CONFIG.HEIGHT - CONFIG.GAME.GROUND_HEIGHT - this.height;
                }
                
                if (this.attackCooldown > 0) {
                    this.attackCooldown--;
                }
            }
            
            takeDamage(amount) {
                this.health -= amount;
                if (this.health < 0) {
                    this.health = 0;
                }
            }
        }

        class BossProjectile {
            constructor(x, y, width, height, target) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                
                const dx = target.x + target.width / 2 - x;
                const dy = target.y + target.height / 2 - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                this.speedX = (dx / distance) * 5;
                this.speedY = (dy / distance) * 5;
            }
            
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
            }
        }

        class Particle {
            constructor(x, y, velocityX, velocityY, color) {
                this.x = x;
                this.y = y;
                this.velocityX = velocityX;
                this.velocityY = velocityY;
                this.color = color;
                this.size = Math.random() * 5 + 2;
                this.lifetime = CONFIG.VISUAL.PARTICLE_LIFETIME;
            }
            
            update() {
                this.x += this.velocityX;
                this.y += this.velocityY;
                this.velocityY += 0.2; // Gravity
                this.lifetime--;
            }
        }

        // ==============================================
        // INITIALIZE GAME
        // ==============================================
        const game = new MagicalRunner();

        // ==============================================
        // TEACHER CONTROL PANEL
        // ==============================================
        window.superGame = {
            start: () => game.start(),
            pause: () => game.pause(),
            resume: () => game.resume(),
            restart: () => game.restart(),
            setInvincible: (value) => {
                game.player.invincible = value;
                if (value) {
                    game.player.invincibleTimer = Number.MAX_SAFE_INTEGER;
                } else {
                    game.player.invincibleTimer = 0;
                }
            },
            spawnBoss: () => game.spawnBoss(),
            givePowerUp: (type) => {
                if (Object.values(PowerUpType).includes(type)) {
                    game.player.activatePowerUp(type);
                }
            },
            setSpeedMultiplier: (n) => {
                game.speed = CONFIG.GAME.INITIAL_SPEED * n;
            },
            getScore: () => game.score,
            setScore: (score) => {
                game.score = score;
                game.updateUI();
            },
            getHighScore: () => game.highScore,
            setHighScore: (score) => {
                game.highScore = score;
                localStorage.setItem('magicalRunnerHighScore', score.toString());
                game.updateUI();
            },
            resetAchievements: () => {
                game.achievements = ACHIEVEMENTS;
                localStorage.setItem('magicalRunnerAchievements', JSON.stringify(game.achievements));
                game.loadAchievementsDisplay();
            },
            unlockAllAchievements: () => {
                game.achievements.forEach(ach => ach.earned = true);
                localStorage.setItem('magicalRunnerAchievements', JSON.stringify(game.achievements));
                game.loadAchievementsDisplay();
            },
            showTutorialHint: (message) => game.showTutorialHint(message),
            getPlayerStats: () => ({
                score: game.score,
                orbsCollected: game.orbsCollected,
                powerupsUsed: game.powerupsUsed,
                achievements: game.achievements.filter(a => a.earned).length,
                totalAchievements: game.achievements.length
            })
        };
    </script>
</body>
</html>